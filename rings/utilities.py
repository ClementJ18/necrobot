import discord
from discord.ext import commands

from rings.utils.utils import has_perms, react_menu, TimeConverter

import random
import aiohttp
import datetime
from simpleeval import simple_eval
from collections import defaultdict

class Utilities():
    """A bunch of useful commands to do various tasks."""
    def __init__(self, bot):
        self.bot = bot
        
        def factory():
            return {"end": True, "list" : []}

        self.queue = defaultdict(factory)

    @commands.command()
    async def calc(self, ctx, *, equation : str):
        """Evaluates a pythonics mathematical equation, use the following to build your mathematical equations:
        `*` - for multiplication
        `+` - for additions
        `-` - for substractions
        `/` - for divisons
        `**` - for exponents
        `%` - for modulo
        More symbols can be used, simply research 'python math symbols'
        
        {usage}
        
        __Example__
        `{pre}calc 2 + 2` - 4
        `{pre}calc (4 + 5) * 3 / (2 - 1)` - 27
        """
        try:
            final = simple_eval(equation)
            await ctx.send(f":1234: | **{final}**")
        except NameError:
            await ctx.send(":negative_squared_cross_mark: | **Mathematical equation not recognized.**")
        except Exception as e:
            await ctx.send(f":negative_squared_cross_mark: | {e}")

    @commands.command(aliases=["pong"])
    async def ping(self, ctx):
        """Pings the user and returns the time it took. 
        
        {usage}"""
        await ctx.send(f'Pong! That took {self.bot.latency * 1000} seconds.')

    @commands.command()
    @commands.guild_only()
    async def serverinfo(self, ctx):
        """Returns a rich embed of the server's information. 
        
        {usage}"""
        guild = ctx.guild
        embed = discord.Embed(title=f"__**{guild.name}**__", colour=discord.Colour(0x277b0), description="Info on this server")
        embed.set_thumbnail(url=guild.icon_url.replace("webp","jpg"))
        embed.set_footer(text="Generated by Necrobot", icon_url=self.bot.user.avatar_url_as(format="png", size=128))

        embed.add_field(name="**Date Created**", value=guild.created_at.strftime("%d - %B - %Y %H:%M"))
        embed.add_field(name="**Owner**", value=str(guild.owner), inline=True)

        embed.add_field(name="**Members**", value=guild.member_count, inline=True)

        embed.add_field(name="**Region**", value=guild.region)
        embed.add_field(name="**Server ID**", value=guild.id, inline=True)

        channel_list = [channel.name for channel in guild.channels]
        channels = ", ".join(channel_list) if len(", ".join(channel_list)) < 1024 else ""
        role_list = [role.name for role in guild.roles]
        roles = ", ".join(role_list) if len(", ".join(role_list)) < 1024 else ""
        embed.add_field(name="**Channels**", value=f"{len(channel_list)}: {channels}", inline=False)
        embed.add_field(name="**Roles**", value=f"{len(role_list)}: {roles}", inline=False)

        await ctx.send(embed=embed)

    @commands.command()
    async def avatar(self, ctx,* , user : discord.Member=None):
        """Returns a link to the given user's profile pic 
        
        {usage}
        
        __Example__
        `{pre}avatar @NecroBot` - return the link to NecroBot's avatar"""
        if user is None:
            user = ctx.author

        avatar = user.avatar_url_as(format="png")
        await ctx.send(embed=discord.Embed().set_image(url=avatar))

    @commands.command()
    async def today(self, ctx, choice : str = None, date : str = None):
        """Creates a rich information about events/deaths/births that happened today or any day you indicate using the 
        `dd/mm` format. The choice argument can be either `events`, `deaths` or `births`.

        {usage}

        __Example__
        `{pre}today` - prints five events/deaths/births that happened today
        `{pre}today 14/02` - prints five events/deaths/births that happened on the 14th of February
        `{pre}today events` - prints five events that happened today
        `{pre}today events 14/02` - prints five events that happened on the 14th of February
        `{pre}today deaths` - prints deaths that happened today
        `{pre}today deaths 14/02` - prints deaths that happened on the 14th of February
        `{pre}today births` - prints births that happened today
        `{pre}today births 14/02` - prints births that happened on the 14th of February"""

        if date:
            r_date = date.split("/")
            date = f"/{r_date[1]}/{r_date[0]}"
        else:
            date = ""

        if choice:
            choice = choice.lower().title()
        else:
            choice = random.choice(["Deaths", "Births", "Events"])

        if not choice in ["Deaths", "Births", "Events"]:
            await ctx.send(":negative_squared_cross_mark: | Not a correct choice. Correct choices are `Deaths`, `Births` or `Events`.")
            return

        async with self.bot.session.get(f'http://history.muffinlabs.com/date{date}') as r:
            try:
                res = await r.json()
            except aiohttp.ClientResponseError:
                res = await r.json(content_type="application/javascript")

        def _embed_generator(index):
            embed = discord.Embed(title=f"__**{res['date']}**__", colour=discord.Colour(0x277b0), url=res["url"], description=f"Necrobot is proud to present: **{choice} today in History**\n Page {index+1}/{len(res['data'][choice])//5+1}")
            embed.set_footer(text="Generated by Necrobot", icon_url=self.bot.user.avatar_url_as(format="png", size=128))
            for event in res["data"][choice][5*index:(index+1)*5]:
                try:
                    if choice == "Events":
                        link_list = "".join(["\n-[{}]({})".format(x["title"], x["link"]) for x in event["links"]])
                        embed.add_field(name=f"Year {event['year']}", value="{}\n__Links__{}".format(event['text'], link_list), inline=False)
                    elif choice == "Deaths":
                        embed.add_field(name=f"Year {event['year']}", value=f"[{event['text'].replace('b.','Birth: ')}]({event['links'][0]['link']})", inline=False)
                    elif choice == "Births":
                        embed.add_field(name=f"Year {event['year']}", value=f"[{event['text'].replace('d.','Death: ')}]({event['links'][0]['link']})", inline=False)
                except AttributeError:
                    pass

            return embed

        random.shuffle(res["data"][choice])
        await react_menu(ctx, len(res["data"][choice])//5, _embed_generator)

    @commands.group(invoke_without_command=True)
    async def remindme(self, ctx, *, message):
        """Creates a reminder in seconds. The following times can be used: days (d), 
        hours (h), minutes (m), seconds (s).

        {usage}

        __Examples__
        `{pre}remindme do the dishes in 40s` - will remind you to do the dishes in 40 seconds
        `{pre}remindme do the dishes in 2m` - will remind you to do the dishes in 2 minutes
        `{pre}remindme do the dishes in 4d2h45m` - will remind you to do the dishes in 4 days, 2 hours and 45 minutes
        """
        if "in" not in message:
            return await ctx.send(":negative_squared_cross_mark: | Something went wrong, you need to use the format <message> in <time>")

        text = message.rpartition(" in ")[0]
        time = message.rpartition(" in ")[-1]
        sleep = await TimeConverter().convert(ctx, time)

        partial = {"channel": ctx.channel.id, "text": text, "timer": time, "start": str(datetime.datetime.now())}
        task = self.bot.loop.create_task(self.bot.reminder_task(ctx.author.id, partial, sleep))
        self.bot.user_data[ctx.author.id]["reminders"].append({**partial, "task": task})

        await self.bot.query_executer("INSERT INTO necrobot.Reminders VALUES($1, $2, $3, $4, $5)",  
                                      ctx.author.id, ctx.channel.id, text, time, str(datetime.datetime.now()))

        await ctx.send(f":white_check_mark: | I will remind you of that in **{time}**")

    @remindme.command(name="delete")
    async def remindme_delete(self, ctx, reminder : int):
        """Cancels a reminder based on its placement on the reminder list. You can check out the placement of each
        reminder using `remindme list`.

        {usage}

        __Examples__
        `{pre}remindme delete 5` - delete the 5th reminder on your remindme list
        `{pre}remindme delete 1` - delete the first reminder on your reminder list
        """
        try:
            reminders = self.bot.user_data[ctx.author.id]["reminders"]
            reminder = reminders[reminder - 1]
        except IndexError:
            await ctx.send(f":negative_squared_cross_mark: | Please pick a reminder between 1 and {len(reminders)}")
            return

        reminder["task"].cancel()
        reminders.remove(reminder)
        await self.bot.query_executer("DELETE FROM necrobot.Reminders WHERE start_date = $1 AND user_id = $2", reminder["start"], ctx.author.id)

        await ctx.send(":white_check_mark: | Reminder cancelled")

    @remindme.command(name="list")
    async def remindme_list(self, ctx, user : discord.Member = None):
        """List all the reminder you currently have in necrobot's typical paginator. All the reminders include their
        position on the remindme list which can be given to `remindme delete` to cancel a reminder.

        {usage}

        __Exampes__
        `{pre}remindme list` - lists all of your reminders
        `{pre}remindme list @NecroBot` - list all of NecroBot's reminder
        """
        if not user:
            user = ctx.author

        def _embed_generator(index):
            embed = discord.Embed(title="Reminders", description=f"Here is the list of **{user.display_name}**'s currently active reminders.", colour=discord.Colour(0x277b0))
            embed.set_footer(text="Generated by Necrobot", icon_url=self.bot.user.avatar_url_as(format="png", size=128))
            
            reminders = self.bot.user_data[user.id]["reminders"]
            for reminder in reminders[index*10: (index+1)*10]:
                embed.add_field(name=f'{reminders.index(reminder) + 1}: {reminder["timer"]}', value=reminder["text"][:500], inline=False)

            return embed

        await react_menu(ctx, len(self.bot.user_data[user.id]["reminders"])//10, _embed_generator)

    @commands.group(invoke_without_command=True)
    @commands.guild_only()
    async def q(self, ctx):
        """Displays the content of the queue at the moment. Queue are shortlive instances, do not use them to
        hold data for extended periods of time. A queue should atmost only last a couple of days.

        {usage}"""
        if self.queue[ctx.guild.id]["list"]:
            queue = [f"**{ctx.guild.get_member(x).display_name}**" for x in self.queue[ctx.guild.id]["list"]]
            await ctx.send("So far the queue has the following users in it:\n-{}".format('\n-'.join(queue)))
        else:
            await ctx.send("So far this queue has no users in it.")

    @q.command(name="start")
    @commands.guild_only()
    @has_perms(2)
    async def q_start(self, ctx):
        """Starts a queue, if there is already an ongoing queue it will fail. The ongoing queue must be cleared first 
        using `{pre}q clear`.

        {usage}"""
        if self.queue[ctx.guild.id]["list"]:
            await ctx.send(":negative_squared_cross_mark: | A queue is already ongoing, please clear the queue first")
            return

        self.queue[ctx.guild.id] = {"end": False, "list" : []}
        await ctx.send(":white_check_mark: | Queue initialized")

    @q.command(name="end")
    @commands.guild_only()
    @has_perms(2)
    async def q_end(self, ctx):
        """Ends a queue but does not clear it. Users will no longer be able to use `{pre}q me`

        {usage}"""
        self.queue[ctx.guild.id]["end"] = True
        await ctx.send(":white_check_mark: | Users will now not be able to add themselves to queue")

    @q.command(name="clear")
    @commands.guild_only()
    @has_perms(2)
    async def q_clear(self, ctx):
        """Ends a queue and clears it. Users will no longer be able to add themselves and the content of the queue will be 
        emptied. Use it in order to start a new queue

        {usage}"""
        self.queue[ctx.guild.id]["list"] = []
        self.queue[ctx.guild.id]["end"] = True
        await ctx.send(":white_check_mark: | Queue cleared and ended. Please start a new queue to be able to add users again")

    @q.command(name="me")
    @commands.guild_only()
    async def q_me(self, ctx):
        """Queue the user that used the command to the current queue. Will fail if queue has been ended or cleared.

        {usage}"""
        if self.queue[ctx.guild.id]["end"]:
            await ctx.send(":negative_squared_cross_mark: | Sorry, you can no longer add yourself to the queue")
            return

        if ctx.author.id in self.queue[ctx.guild.id]["list"]:
            await ctx.send(":white_check_mark: | You have been removed from the queue")
            self.queue[ctx.guild.id]["list"].remove(ctx.author.id)
            return

        self.queue[ctx.guild.id]["list"].append(ctx.author.id)
        await ctx.send(":white_check_mark: |  You have been added to the queue")

    @q.command(name="next")
    @commands.guild_only()
    @has_perms(2)
    async def q_next(self, ctx):
        """Mentions the next user and the one after that so they can get ready.
        
        {usage}"""
        if not self.queue[ctx.guild.id]["list"]:
            await ctx.send(":negative_squared_cross_mark: | No users left in that queue")
            return

        msg = f":bell: | {ctx.guild.get_member(self.queue[ctx.guild.id]['list'][0]).mention}, you're next. Get ready!"

        if len(self.queue[ctx.guild.id]["list"]) > 1:
            msg += f" \n{ctx.guild.get_member(self.queue[ctx.guild.id]['list'][1]).mention}, you're right after them. Start warming up!"
        else:
            msg += "\nThat's the last user in the queue"

        await ctx.send(msg)
        self.queue[ctx.guild.id]["list"].pop(0)

    @commands.command()
    async def convert(self, ctx, measure : float, symbol, conversion = None):
        """The ultimate conversion tool to bridge the gap with America/UK and the rest of the world. Can convert most metric
        units to imperial and most imperial units to metric. This works for lenght, temperature and mass measures.

        {usage}

        __Example__
        `{pre}convert 10 ft m` - convert 10 feet into meters
        `{pre}convert 5 km in`  - convert 5 kilometers to inches"""
        def m_to_i(measure, symbol, conversion):
            index = m_values.index(symbol)
            measure *= (10**(index)) #convert to milimiters
            measure /= 25.4 #convert to inches

            #convert to requested imperial
            index = i_values.index(conversion)
            for value in i_conver[index:]:
                measure /= value

            return measure

        def i_to_m(measure, symbol, conversion):
            index = i_values.index(symbol)
            for value in i_conver[index:]:
                measure *= value

            measure *= 25.4 # converter to milimiters
            index = m_values.index(conversion)
            measure /= (10**(index))#convert to requested metric

            return measure

        def temp(f=None, c=None):
            if c:
                return c * 9/5 + 32

            if f:
                return (f - 32) * 5/9

            return None

        def mass_i_to_m(measure, symbol, conversion):
            #convert to oz
            index = mass_i_values.index(symbol)
            for value in mass_i_conver[index:]:
                measure = measure * value

            measure = measure * 28349.5 #convert to miligrams
            index = mass_m_values.index(conversion)
            measure /= (10**(index)) #convert to requested imperial

            return measure

        def mass_m_to_i(measure, symbol, conversion):
            index = mass_m_values.index(symbol)
            measure *= (10**(index)) # convert to miligrams
            measure = measure / 28349.5 #convert to oz

            #convert to requested imperial
            index = mass_i_values.index(conversion)
            for value in mass_i_conver[index:]:
                measure = measure / value

            return measure

        m_values = ['mm', 'cm', 'm', 'km']
        i_values = ["ml", "yd", "ft", "in"]
        i_conver = [1760, 3, 12]

        mass_m_values = ["mg", "g", "kg", "t"]
        mass_i_values = ["t", "lb", "oz"]
        mass_i_conver = [2204.62, 16]

        if symbol in m_values and conversion in i_values:
            measure = m_to_i(measure, symbol, conversion)
        elif symbol in i_values and conversion in m_values:
            measure = i_to_m(measure, symbol, conversion)
        elif symbol in mass_m_values and conversion in mass_i_values:
            measure = mass_m_to_i(measure, symbol, conversion)
        elif symbol in mass_i_values and conversion in mass_m_values:
            measure = mass_i_to_m(measure, symbol, conversion)
        elif symbol == 'c':
            measure = temp(c=measure)
        elif symbol == 'f':
            measure = temp(f=measure)
        else:
            msg = ":negative_squared_cross_mark: | Not a convertible symbol. \nImperial length unit symbols: {}\nImperial weight/mass unit symbols: {}\nMetric length unit symbols: {}\nMetric weight/mass unit symbols: {}\nTemperature unit symbols: c - f"
            await ctx.send(msg.format(" - ".join(i_values), " - ".join(mass_i_values), " - ".join(m_values), " - ".join(mass_m_values)))
            return

        await ctx.send(f":white_check_mark: | **{measure:.2f}{conversion}**")
        
    @commands.group(invoke_without_command=True)
    async def leaderboard(self, ctx, page : int = 0):
        """Base command for the leaderboard, a fun system built for servers to be able to have their own arbitrary 
        point system.
        
        {usage}
        
        __Examples__
        `{pre}leaderboard` - show the leaderboard starting from page zero
        `{pre}leaderboard 3` - show the leaderboard starting from page 3
        """
        settings = (await self.bot.query_executer("SELECT * FROM necrobot.Leaderboards WHERE id=$1", ctx.guild.id))[0]
        if settings[1] == "":
            return await ctx.send(":negative_squared_cross_mark: | Leaderboard isn't currently enabled")
        
        results = await self.bot.query_executer(
            "SELECT * FROM necrobot.LeaderboardPoints WHERE board=$1 ORDER BY points DESC",
            ctx.guild.id
        )
        
        def _embed_maker(index):
            users = []
            for result in results[10*index:10*(index+1)]:
                user = ctx.guild.get_member(result[0])
                if user is not None:
                    users.append(f"- {user.mention}: {result[2]} {settings[2]}")
            
            users = "\n\n".join(users)
            msg = f"{settings[1]}\n\n{users}"
            embed = discord.Embed(title=f"Leaderboard ({index}/{len(results)//10})", colour=discord.Colour(0x277b0), description=msg)
            embed.set_footer(text="Generated by Necrobot", icon_url=self.bot.user.avatar_url_as(format="png", size=128))

            return embed
                        
        await react_menu(ctx, len(results)//10, _embed_maker, page)
        
    @leaderboard.command(name="message")
    @has_perms(4)
    async def leaderboard_message(self, ctx, *, message : str = ""):
        """Enable the leaderboard and set a message. (Permission level of 4+)
        
        {usage}
        
        __Examples__
        `{pre}leaderboard message` - disable leaderboards
        `{pre}leaderboard message Server's Favorite People` - enable leaderboards and make 
        """
        if message == "":
            await ctx.send(":white_check_mark: | Leaderboard disabled")
        elif len(message) > 200:
            return await ctx.send(":negative_squared_cross_mark: | The message cannot be more than 200 characters")
        else:
            await ctx.send(":white_check_mark: | Leaderboard message changed")
            for member in ctx.guild.members:
                await self.bot.query_executer("INSERT INTO necrobot.LeaderboardPoints VALUES($1, $2, 0) ON CONFLICT (id, board) DO NOTHING", member.id,ctx.guild.id)
        
            
        await self.bot.query_executer("UPDATE necrobot.Leaderboards SET message=$1 WHERE id=$2", message, ctx.guild.id)
        
    @leaderboard.command(name="symbol")
    @has_perms(4)
    async def leaderboard_symbol(self, ctx, *, symbol):
        """Change the symbol for your points (Permission level of 4+)
        
        {usage}
        
        __Examples__
        `{pre}leaderboard symbol $` - make the symbol $
        """
        settings = (await self.bot.query_executer("SELECT * FROM necrobot.Leaderboards WHERE id=$1", ctx.guild.id))[0]
        if settings[1] == "":
            return await ctx.send(":negative_squared_cross_mark: | Leaderboard isn't currently enabled")
        
        if len(symbol) > 10:
            return await ctx.send(":negative_squared_cross_mark: | The symbol cannot be more than 10 characters")
        else:
            await ctx.send(":white_check_mark: | Leaderboard symbol changed")
            
        await self.bot.query_executer("UPDATE necrobot.Leaderboards SET symbol=$1 WHERE id=$2", symbol, ctx.guild.id)
    
    @has_perms(2)
    @leaderboard.command(name="award")
    async def leaderboard_award(self, ctx, user : discord.Member, points : int):
        """Add remove some points. (Permission level of 2+)
        
        {usage}
        
        __Examples__
        `{pre}leaderboard award 340` - award 340 points
        `{pre}leaderboard award -34` - award -34 points, effectively removing 34 points.
        """
        
        settings = (await self.bot.query_executer("SELECT * FROM necrobot.Leaderboards WHERE id=$1", ctx.guild.id))[0]
        if settings[1] == "":
            return await ctx.send(":negative_squared_cross_mark: | Leaderboard isn't currently enabled")
        
        if points > 0:
            await ctx.send(f"{user.mention}, you have been awarded {points}{settings[2]}")
        else:
            await ctx.send(f"{user.mention}, {points}{settings[2]} has been taken from you")
            
        await self.bot.query_executer(
            "UPDATE necrobot.LeaderboardPoints SET points = points + $1 WHERE id=$2 AND board=$3", 
            points, user.id, ctx.guild.id
        )
    
def setup(bot):
    bot.add_cog(Utilities(bot))
