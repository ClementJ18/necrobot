#!/usr/bin/python3.6
import discord
from discord.ext import commands
from discord.ext.commands.cooldowns import BucketType
from simpleeval import simple_eval
import time
import dice
import aiohttp
import random
from overwatch_api.core import AsyncOWAPI
from overwatch_api.constants import *
import re
import json
import asyncio

ball8List = ["It is certain"," It is decidedly so"," Without a doubt","Yes, definitely","You may rely on it","As I see it, yes"," Most likely","Outlook good","Yes","Signs point to yes","Reply hazy try again","Ask again later","Better not tell you now"," Cannot predict now","Concentrate and ask again","Don't count on it"," My reply is no","My sources say no","Outlook not so good","Very doubtful"]


class Utilities():
    """A bunch of useful commands to do various tasks."""
    def __init__(self, bot):
        self.bot = bot

    @commands.command()
    @commands.cooldown(3, 5, BucketType.user)
    async def calc(self, *, equation : str):
        """Evaluates a pythonics mathematical equation, use the following to build your mathematical equations:
        `*` - for multiplication
        `+` - for additions
        `-` - for substractions
        `/` - for divisons
        `**` - for exponents
        `%` - for modulo
        More symbols can be used, simply research 'python math symbols'
        
        {usage}
        
        __Example__
        `{pre}calc 2 + 2` - 4
        `{pre}calc (4 + 5) * 3 / (2 - 1)` - 27
        """
        try:
            final = simple_eval(equation)
            await self.bot.say(":1234: | **" + str(final) + "**")
        except NameError:
            await self.bot.say(":negative_squared_cross_mark: | **Mathematical equation not recognized.**")

    @commands.command(pass_context=True, aliases=["pong"])
    @commands.cooldown(3, 5, BucketType.user)
    async def ping(self, cont):
        """Pings the user and returns the time it took. 
        
        {usage}"""
        pingtime = time.time()
        pingms = await self.bot.say(" :clock1: | Pinging... {}'s location".format(cont.message.author.display_name))
        ping = time.time() - pingtime
        await self.bot.edit_message(pingms, ":white_check_mark: | The ping time is `% .01f seconds`" % ping)

    #prints a rich embed of the server info it was called in
    @commands.command(pass_context = True)
    @commands.cooldown(1, 5, BucketType.user)
    async def serverinfo(self, cont):
        """Returns a rich embed of the server's information. 
        
        {usage}"""
        server = cont.message.server
        embed = discord.Embed(title="__**{}**__".format(server.name), colour=discord.Colour(0x277b0), description="Info on this server")
        embed.set_thumbnail(url=server.icon_url.replace("webp","jpg"))
        embed.set_footer(text="Generated by NecroBot", icon_url="https://cdn.discordapp.com/avatars/317619283377258497/a491c1fb5395e699148fcfed2ee755cf.jpg?size=128")

        embed.add_field(name="**Date Created**", value=server.created_at.strftime("%d - %B - %Y %H:%M"))
        embed.add_field(name="**Owner**", value=server.owner.name + "#" + server.owner.discriminator, inline=True)

        embed.add_field(name="**Default Channel**", value=server.default_channel)
        embed.add_field(name="**Members**", value=server.member_count, inline=True)

        embed.add_field(name="**Region**", value=server.region)
        embed.add_field(name="**Server ID**", value=server.id, inline=True)

        channelList = [channel.name for channel in server.channels]
        roleList = [role.name for role in server.roles]
        embed.add_field(name="**Channels**", value="{}: {}".format(len(channelList), ", ".join(channelList)))
        embed.add_field(name="**Roles**", value="{}: {}".format(len(roleList), ", ".join(roleList)))

        await self.bot.say(embed=embed)

    @commands.command(pass_context = True)
    @commands.cooldown(5, 10, BucketType.channel)
    async def avatar(self,cont, *user : discord.Member):
        """Returns a link to the given user's profile pic 
        
        {usage}
        
        __Example__
        `{pre}avatar @NecroBot` - return the link to NecroBot's avatar"""
        if not user:
            user = cont.message.author
        else:
            user = user[0]

        await self.bot.say(user.avatar_url.replace("webp","jpg"))

    @commands.command()
    @commands.cooldown(5, 5, BucketType.user)
    async def choose(self, *, choices):
        """Returns a single choice from the list of choices given. Use `|` to seperate each of the choices.
        
        {usage}
        
        __Example__
        `{pre}choose Bob | John | Mary` - choose between the names of Bob, John, and Mary
        `{pre}choose 1 | 2` - choose between 1 and 2 """
        choiceList = [x.strip() for x in choices.split("|")]
        await self.bot.say("I choose **" + random.choice(choiceList) + "**")

    @commands.command(aliases=["flip"])
    @commands.cooldown(5, 5, BucketType.user)
    async def coin(self):
        """Flips a coin and returns the result
        
        {usage}"""
        await self.bot.say(random.choice(["<:head:351456287453872135> **Head**","<:tail:351456234257514496> | **Tail**"]))

    @commands.command(pass_context = True)
    @commands.cooldown(5, 5, BucketType.user)
    async def roll(self, cont, dices="1d6"):
        """Rolls one or multiple x sided dices and returns the result. Structure of the argument: `[number of die]d[number of faces]` 
        
        {usage}
        
        __Example__
        `{pre}roll 3d8` - roll three 8-sided die
        `{pre}roll` - roll one 6-sided die"""
        await self.bot.say(":game_die: | {} rolled {}".format(cont.message.author.display_name, dice.roll(dices)))

    @commands.command(name="8ball")
    @commands.cooldown(3, 5, BucketType.user)
    async def ball8(self):
        """Uses an 8ball system to reply to the user's question. 
        
        {usage}"""
        await self.bot.say(":8ball: | " + random.choice(ball8List))

    @commands.group(pass_context = True, invoke_without_command = True)
    async def today(self, cont, date : str =""):
        """Creates a rich information about events/deaths/births that happened today or any day you indicate using the `mm/dd` format

        {usage}

        __Example__
        `{pre}today ` - prints stuff that happened today
        `{pre}today 02/14` - prints stuff that happened on the 14th of February"""

        await cont.invoke(self.bot.get_command("today {}".format(random.choice(["events", "deaths", "births"]))),date)
        

    @today.command(name="events")
    async def today_events(self, date=""):
        """Creates a rich information about events that happened today or any day you indicate using the `mm/dd` format

        {usage}

        __Example__
        `{pre}today events` - prints five events that happened today
        `{pre}today events 02/14` - prints five events that happened on the 14th of February"""
        if date != "":
            date = "/"+date


        async with aiohttp.ClientSession() as cs:
            async with cs.get('http://history.muffinlabs.com/date'+date) as r:
                try:
                    res = await r.json(content_type="text/html")
                except:
                     res = await r.json(content_type="application/javascript")

        embed = discord.Embed(title="__**" + res["date"] + "**__", colour=discord.Colour(0x277b0), url=res["url"], description="Necrobot is proud to present: **Events today in History**")
        embed.set_footer(text="Generated by NecroBot", icon_url="https://cdn.discordapp.com/avatars/317619283377258497/a491c1fb5395e699148fcfed2ee755cf.jpg?size=128")
        
        for event in random.sample(res["data"]["Events"],5):
            link_list = "".join(["\n-[{}]({})".format(x["title"], x["link"]) for x in event["links"]])
            embed.add_field(name="Year {}".format(event["year"]), value="{}\n__Links__{}".format(event["text"], link_list), inline=False)

        await self.bot.say(embed=embed)

    @today.command(name="deaths")
    async def today_deaths(self, date=""):
        """Creates a rich information about deaths that happened today or any day you indicate using the `mm/dd` format

        {usage}

        __Example__
        `{pre}today deaths` - prints deaths that happened today
        `{pre}today deaths 02/14` - prints deaths that happened on the 14th of February"""
        if date != "":
            date = "/"+date


        async with aiohttp.ClientSession() as cs:
            async with cs.get('http://history.muffinlabs.com/date'+date) as r:
                try:
                    res = await r.json(content_type="text/html")
                except:
                     res = await r.json(content_type="application/javascript")

        embed = discord.Embed(title="__**" + res["date"] + "**__", colour=discord.Colour(0x277b0), url=res["url"], description="Necrobot is proud to present: **Deaths today in History**")
        embed.set_footer(text="Generated by NecroBot", icon_url="https://cdn.discordapp.com/avatars/317619283377258497/a491c1fb5395e699148fcfed2ee755cf.jpg?size=128")

        for death in random.sample(res["data"]["Deaths"], 20):
            embed.add_field(name="Year {}".format(death["year"]), value="[{}]({})".format(death["text"].replace("b.","Birth: "), death["links"][0]["link"]), inline=False)

        await self.bot.say(embed=embed)


    @today.command(name="births")
    async def today_births(self, date=""):
        """Creates a rich information about births that happened today or any day you indicate using the `mm/dd` format

        {usage}

        __Example__
        `{pre}today births` - prints births that happened today
        `{pre}today births 02/14` - prints births that happened on the 14th of February"""
        if date != "":
            date = "/"+date


        async with aiohttp.ClientSession() as cs:
            async with cs.get('http://history.muffinlabs.com/date'+date) as r:
                try:
                    res = await r.json(content_type="text/html")
                except:
                     res = await r.json(content_type="application/javascript")


        embed = discord.Embed(title="__**" + res["date"] + "**__", colour=discord.Colour(0x277b0), url=res["url"], description="Necrobot is proud to present: **Births today in History**")
        embed.set_footer(text="Generated by NecroBot", icon_url="https://cdn.discordapp.com/avatars/317619283377258497/a491c1fb5395e699148fcfed2ee755cf.jpg?size=128")

        for birth in random.sample(res["data"]["Births"], 5):
            embed.add_field(name="Year {}".format(birth["year"]), value="[{}]({})".format(birth["text"].replace("d.","Death: "), birth["links"][0]["link"]), inline=False)

        await self.bot.say(embed=embed)

    def get_a_hero_stat(self, data, username, hero_int, hero_list):
        embed = discord.Embed(title="__**" + username + "**__", colour=discord.Colour(0x277b0), description=hero_list[hero_int].title())
        embed.set_footer(text="Generated by NecroBot", icon_url="https://cdn.discordapp.com/avatars/317619283377258497/a491c1fb5395e699148fcfed2ee755cf.jpg?size=128")

        s = data["pc"]["us"]["stats"]["quickplay"][hero_list[hero_int]]

        # general stats
        stats = list()
        to_find = ["deaths", "medals", "weapon_accuracy", "all_damage_done", "kill_streak_best", "time_played", "games_won"]
        for x in to_find:
            try:
                title = x
                if "most" in x:
                    title = "Most " + x.replace("most_", "")

                stats.append(title.replace("_", " ").title() + ": " + "{0:.2f}".format(s["general_stats"][x]))
            except KeyError:
                pass

        embed.add_field(name="General Stats", value="-" + "\n-".join(stats), inline=False)

        # hero specific stats
        stats = list()
        for x in s["hero_stats"]:
            title = x
            if "most" in x:
                title = "Most " + x.replace("most_", "")

            stats.append(title.replace("_", " ").title() + ": " + "{0:.2f}".format(s["hero_stats"][x]))

        embed.add_field(name="Hero Stats", value="-" + "\n-".join(stats), inline=False)

        return embed


    @commands.command(pass_context = True)
    async def ow(self, cont, username):
        """Creates a rich embed of the user's Owerwatch stats for PC only. You must parse through a valid Battle.NET Battle Tag.

        {usage}

        __Example__
        `{pre}ow FakeTag#1234` - generates the embed for user FakeTag#1234"""
        hero_int = 0
        client = AsyncOWAPI()
        data = {}
        username = re.sub(" -", "#", username)
        msg = await self.bot.say("Gathering data...")

        async with aiohttp.ClientSession(connector=aiohttp.TCPConnector(verify_ssl=False)) as session:
            try:
                await self.bot.edit_message(msg, 'Gathering data...[get_profile PC]')
                data[PC] = await client.get_profile(username, session=session, platform=PC)
                # await self.bot.edit_message(msg, 'Gathering data...[get_profile XBOX]')
                # data[XBOX] = await client.get_profile(username, session=session, platform=XBOX)
                # await self.bot.edit_message(msg, 'Gathering data...[get_profile PLAYSTATION]')
                # data[PLAYSTATION] = await client.get_profile(username, session=session, platform=PLAYSTATION)
                await self.bot.edit_message(msg, 'Gathering data....[get_stats PC]')
                data[PC] = await client.get_stats(username, session=session, platform=PC)
                # await self.bot.edit_message(msg, 'Gathering data...[get_stats XBOX]')
                # data[XBOX] = await client.get_stats(username, session=session, platform=XBOX)
                # await self.bot.edit_message(msg, 'Gathering data...[get_stats PLAYSTATION]')
                # data[PC] = await client.get_stats(username, session=session, platform=PLAYSTATION)
                await self.bot.edit_message(msg, 'Gathering data...[get_achievements PC]')
                data[PC] = await client.get_achievements(username, session=session, platform=PC)
                await self.bot.edit_message(msg, 'Gathering data...[get_hero_stats PC]')
                data[PC] = await client.get_hero_stats(username, session=session, platform=PC)
                await self.bot.edit_message(msg, 'Gathering data...[done]')
            except asyncio.TimeoutError:
                await self.bot.edit_message(msg, 'Time out error has occured. Please try again.')

        try:
            heroes = data["pc"]["us"]["stats"]["quickplay"]
            hero_list = list(data["pc"]["us"]["stats"]["quickplay"].keys())
        except KeyError:
            await self.bot.say("Something went terribly wrong", delete_after=10)
            return

        await self.bot.delete_message(msg)
        msg = await self.bot.say(embed=self.get_a_hero_stat(data, username, hero_int, hero_list))

        while True:
            asyncio.sleep(1)
            react_list = list()
            if hero_int > 0:
                react_list.append("\N{BLACK LEFT-POINTING TRIANGLE}")

            react_list.append("\N{BLACK SQUARE FOR STOP}")

            if hero_int < len(hero_list) - 1:
                react_list.append("\N{BLACK RIGHT-POINTING TRIANGLE}")

            for x in react_list:
                await self.bot.add_reaction(msg, x)

            res = await self.bot.wait_for_reaction(react_list, message=msg, user=cont.message.author, timeout=300)

            if res.reaction.emoji == "\N{BLACK SQUARE FOR STOP}":
                await self.bot.clear_reactions(msg)
                break
            elif res.reaction.emoji == "\N{BLACK LEFT-POINTING TRIANGLE}":
                hero_int -= 1
            elif res.reaction.emoji == "\N{BLACK RIGHT-POINTING TRIANGLE}":
                hero_int += 1

            await self.bot.clear_reactions(msg)
            await self.bot.edit_message(msg, embed=self.get_a_hero_stat(data, username, hero_int, hero_list))
            asyncio.sleep(1)




def setup(bot):
    bot.add_cog(Utilities(bot))

