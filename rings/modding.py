import discord
from discord.ext import commands
from rings.utils.utils import react_menu

from bs4 import BeautifulSoup
from fuzzywuzzy import process
import moddb
from typing import Union
import async_modio
import asyncio

class Modding():
    """This module is used to connect to the various modding communities and allow to link and showcase work using
    commands that determine which modding community to piggy back off and then subcommands which decide
    what you want to show."""
    def __init__(self, bot):
        self.bot = bot

    def __local__check(self, ctx):
        if not ctx.guild:
            raise commands.CheckFailure("Cannot use this command outside a server")

        return True
        
    @commands.group()
    async def moddb(self, ctx):
        """The central command for looking up games and mods on moddb. This allows to separate mod.io and 
        moddb commands.
        
        {usage}

        __Examples__
        `{pre}moddb game Warband` - returns the first game that matches the name warband the closest
        `{pre}moddb mod edain mod` - returns the first game that matches the name edain mod the closest
        """
        pass

    @moddb.command(name="game")
    async def moddb_game(self, ctx, *, game : str):
        """This command takes in a game name from ModDB and returns a rich embed of it. Due to the high variety of 
        game formats, embed appearances will vary but it should always return one as long as it is given the name of
        an existing game
        
        {usage}
        
        __Example__
        `{pre}moddb game battle for middle earth` - creates a rich embed of the BFME ModDB page"""
        def _embed_generator(page):
            embed = discord.Embed(title=f"__**{game.name}**__", colour=discord.Colour(0x277b0), url=url, description=game.summary)
            embed.set_author(name="ModDB", url="http://www.moddb.com", icon_url="http://i.imgur.com/aExydLm.png")
            embed.set_footer(text="Generated by Necrobot", icon_url=self.bot.user.avatar_url_as(format="png", size=128))

            sections = ["Articles", "Reviews", "Downloads", "Videos", "Images"]
            nav_bar = [f"[{x}]({url}/{x.lower()})" for x in sections]
            embed.add_field(name="Navigation", value=" - ".join(nav_bar))

            if page == 0:
                for article in game.articles[:4]:
                    embed.add_field(name=article.name, value=f"{article.summary}... [Link]({article.url})")
            elif page == 1:
                embed.add_field(name="\u200b", value=" ".join([f"[#{tag}]({url})" for tag, url in game.tags.items()]))
                embed.add_field(name="Misc: ", value=f"{game.rating}/10 \n{game.profile.release.strftime('%d-%b-%Y')}\n[{game.profile.engine.name}]({game.profile.engine.url})\n**[Comment]({game.url}#commentform)**  -  **[Follow]({game.profile.follow})**")
                embed.add_field(name="Stats", value=f"Rank: {game.stats.rank}/{game.stats.total}\nVisits: {game.stats.today}\nFiles:  {game.stats.files}\nArticles: {game.stats.articles}\nReviews: {game.stats.reviews}")
            elif page == 2:
                suggestion_list = [f"[{suggestion.name}]({suggestion.url})" for suggestion in game.suggestions]
                embed.add_field(name="You may also like", value=" \n- ".join(suggestion_list))

            return embed

        async with self.bot.session.get(f"https://www.moddb.com/games?filter=t&kw={game.replace(' ', '+')}&released=&genre=&theme=&indie=&players=&timeframe=") as resp:
            soup = BeautifulSoup(await resp.text(), "html.parser")
            
        try:
            search_return = process.extract(game, [x.string for x in soup.find("div", class_="table").findAll("h4")])[0][0]
        except IndexError:
            await ctx.send(":negative_squared_cross_mark: | No game with that name found")
            return
            
        url = moddb.utils.join(soup.find("div", class_="table").find("h4", string=search_return).a["href"])

        async with self.bot.session.get(url) as resp:
            soup = BeautifulSoup(await resp.text(), "html.parser")

        game = moddb.pages.Game(soup)
        await react_menu(ctx, 2, _embed_generator)

    @moddb.command(name="mod")
    async def moddb_mod(self, ctx, *, mod : str):
        """This command takes in a mod name from ModDB and returns a rich embed of it. Due to the high variety of 
        mod formats, embed appearances will vary but it should always return one as long as it is given the name of
        an existing mod
        
        {usage}
        
        __Example__
        `{pre}moddb mod edain mod` - creates a rich embed of the Edain Mod ModDB page"""
        def _embed_generator(page):
            embed = discord.Embed(title=f"__**{mod.name}**__", colour=discord.Colour(0x277b0), url=url, description=mod.summary)
            embed.set_author(name="ModDB", url="http://www.moddb.com", icon_url="http://i.imgur.com/aExydLm.png")
            embed.set_footer(text="Generated by Necrobot", icon_url=self.bot.user.avatar_url_as(format="png", size=128))

            sections = ["Articles", "Reviews", "Downloads", "Videos", "Images"]
            nav_bar = [f"[{x}]({url}/{x.lower()})" for x in sections]
            embed.add_field(name="Navigation", value=" - ".join(nav_bar))

            if page == 0:
                for article in mod.articles[:4]:
                    embed.add_field(name=article.name, value=f"{article.summary}... [Link]({article.url})")
            elif page == 1:
                embed.add_field(name="\u200b", value=" ".join([f"[#{tag}]({url})" for tag, url in mod.tags.items()]))
                embed.add_field(name="Misc: ", value=f"{mod.rating}/10 \n{mod.profile.release.strftime('%d-%b-%Y')}\n[{mod.profile.game.name}]({mod.profile.game.url})\n**[Comment]({mod.url}#commentform)**  -  **[Follow]({mod.profile.follow})**")
                embed.add_field(name="Stats", value=f"Rank: {mod.stats.rank}/{mod.stats.total}\nVisits: {mod.stats.today}\nFiles:  {mod.stats.files}\nArticles: {mod.stats.articles}\nReviews: {mod.stats.reviews}")
            elif page == 2:
                suggestion_list = [f"[{suggestion.name}]({suggestion.url})" for suggestion in mod.suggestions]
                embed.add_field(name="You may also like", value=" \n- ".join(suggestion_list))

            return embed

        async with self.bot.session.get(f"http://www.moddb.com/mods?filter=t&kw={mod.replace(' ', '+')}&released=&genre=&theme=&players=&timeframe=&mod=&sort=visitstotal-desc") as resp:
            soup = BeautifulSoup(await resp.text(), "lxml")
            
        try:
            search_return = process.extract(mod, [x.string for x in soup.find("div", class_="table").findAll("h4")])[0][0]
        except IndexError:
            await ctx.send(":negative_squared_cross_mark: | No mod with that name found")
            return

        url = moddb.utils.join(soup.find("div", class_="table").find("h4", string=search_return).a["href"])

        async with self.bot.session.get(url) as resp:
            soup = BeautifulSoup(await resp.text(), "html.parser")

        mod = moddb.pages.Mod(soup)
        await react_menu(ctx, 2, _embed_generator)

    @commands.group()
    async def modio(self, ctx):
        """Base of the modio command line, used to invoke various subcommands. If this is the first
        time you use any of the commands on this server you must first set a game using the `modio game`
        command. This command tree is much more extensive than the moddb command tree

        {usage}

        __Examples__
        `{pre}modio game` - allows you to navigate through the list of games on mod.io
        `{pre}modio game Aground` - shows the game that matches the text Aground  the closestand gives you 
        the option of setting it as your game for this server. You must set a game in order to lookup mods.
        `{pre}modio game search Giant` - shows you a list of games and their ids that have Giant in their name
        `{pre}modio game 2` - shows the game with id 2 and gives you the option of setting it as your game

        `{pre}modio mod` - allows you to navigate a list of all the mods for the game you've set
        `{pre}modio mod 2` - shows you the mod with id number 2 if it exists for the game you've set
        `{pre}modio mod Lasers` - shows you the game that matches most closely the text 'Lasers' in their title 
        for the game you've set
        `{pre}modio mod search Lasers` - shows you a list of mods and their ids that have Lasers in their name  for
        the game you've set
        """
        pass

    @modio.group(name="game", invoke_without_command=True)
    async def modio_game(self, ctx, *, value : Union[int, str] = None):
        """Used to get a game by either id or name or set a game as the game you want to be looking
        for mods on this server. Setting a game is important since modio requires a game id in order to
        look for mod.

        {usage}

        __Examples__
        `{pre}modio game` - allows you to navigate through the list of games on mod.io
        `{pre}modio game Aground` - shows the game that matches the text Aground  the closestand gives you 
        the option of setting it as your game for this server. You must set a game in order to lookup mods.
        `{pre}modio game 2` - shows the game with id 2 and gives you the option of setting it as your game
        """
        if value is None:
            games = (await self.bot.modio.get_games()).results

            def _embed_maker(index):
                description = "\n".join([f"- {game.name} ({game.id})" for game in games[index*15:(index+1)*15]])
                embed = discord.Embed(title=f"Games on mod.io", url="https://mod.io/", description=description)
                embed.set_footer(text="Generated by Necrobot", icon_url=self.bot.user.avatar_url_as(format="png", size=128))

                return embed

            return await react_menu(ctx, len(games)//15, _embed_maker)

        if isinstance(value, str):
            fltr = async_modio.Filter().text(value)
            games = (await self.bot.modio.get_games(filter=fltr)).results
            if not games:
                return await ctx.send(":negative_squared_cross_mark: | Couldn't find that game")

            game = process.extractOne(value, [x.name for x in games])[0]
            game = discord.utils.get(games, name=game)
        else:
            try:
                game = await self.bot.modio.get_game(value)
            except Exception as e:
                return await ctx.send(f":negative_squared_cross_mark: | {e}")

        embed = discord.Embed(title=game.name, colour=discord.Colour(0x277b0), url=game.profile, description=game.summary)
        embed.set_author(name=game.submitter.username, url=game.submitter.profile, icon_url=game.submitter.avatar.original)
        embed.set_footer(text="Generated by Necrobot", icon_url=self.bot.user.avatar_url_as(format="png", size=128))

        embed.add_field(name="Dates", value=f'''
            - Published: {game.date.strftime("%d %B %Y %H:%M:%S")}
            - Last Updated: {game.updated.strftime("%d %B %Y %H:%M:%S")}
            - Live: {game.live.strftime("%d %B %Y %H:%M:%S")}
        ''')
        nl = '\n'
        mods = await game.get_mods(filter=async_modio.Filter().sort("sort_popular").limit(5))
        embed.add_field(name="Info", value=f'''
            - ID: {game.id}
            - URL: {game.profile} {f"{nl}- Homepage: {game.homepage}" if game.homepage else ""}
            - Mods: {mods.pagination.total}
        ''')

        embed.add_field(name="Popular Mods", value="- "+"\n- ".join([f'[{x.name}]({x.profile}) ({x.stats.rank}/{x.stats.rank_total})' for x in mods.results]))

        embed.set_image(url=game.logo.original)

        msg = await ctx.send("Set this game as the game to look for mods in (Press:white_check_mark:)? Want to subscribe to events for this game's mod (Press :mailbox:)? You can unsubscribe by pressing :mailbox_closed:.", embed=embed)
        await msg.add_reaction("\N{WHITE HEAVY CHECK MARK}")
        await msg.add_reaction("\N{NEGATIVE SQUARED CROSS MARK}")
        await msg.add_reaction("\N{CLOSED MAILBOX WITH RAISED FLAG}")

        def check(reaction, user):
            return user == ctx.author and str(reaction.emoji) in ["\N{WHITE HEAVY CHECK MARK}", "\N{NEGATIVE SQUARED CROSS MARK}"] and msg.id == reaction.message.id

        try:
            reaction, _ = await self.bot.wait_for("reaction_add", check=check, timeout=300)
        except asyncio.TimeoutError:
            return await msg.clear_reactions()

        if reaction.emoji == "\N{WHITE HEAVY CHECK MARK}":
            self.bot.games[ctx.author.id][ctx.guild.id] = game
            await self.bot.query_executer("""INSERT INTO necrobot.Modio VALUES ($1, $2, $3) ON CONFLICT ON CONSTRAINT 
                modio_pkey DO UPDATE SET game_id=$3""", ctx.author.id, ctx.guild.id, game.id)
            await ctx.send(":white_check_mark: | This game will be used when looking for a mod")

        return await msg.clear_reactions()

    @modio_game.command(name="search")
    async def modio_game_search(self, ctx, query):
        """Search for games based on text query.

        {usage}

        __Example__
        `{pre}modio game search Giant` - shows you a list of games and their ids that have Giant in their name
        """
        filtr = async_modio.Filter().text(query)
        games = (await self.bot.modio.get_games(filter=filtr)).results

        def embed_maker(index):
            description = "\n".join([f"- {game.name} ({game.id})" for game in games[index*15:(index+1)*15]])
            embed = discord.Embed(title=f"Games on mod.io", url="https://mod.io/", description=description)
            embed.set_footer(text="Generated by Necrobot", icon_url=self.bot.user.avatar_url_as(format="png", size=128))

            return embed

        return await react_menu(ctx, len(games)//15, embed_maker)

    # @modio_game.command(name="subscribe")
    # async def modio_game_subscribe(self, ctx, game_id : int, *, events):
    #     """Possible events, each event must be separated by `,`:
    #     - file changed: a file has been edited
    #     - available: a mod becomes available
    #     - unavailable: a mod becomes unavailable
    #     - edited: a mod is edited
    #     - deleted: a mod was deleted
    #     - team leave: a user has left a mod team
    #     - team join: a user has joined a mod team
    #     - unsubscribe: a user has unsubscribed to the mod
    #     - subscribe: a user has subscribed to the mod
    #     """
    #     events = [x.trim().lower().replace(" ", "_") for even in events.split(",")]
    #     enums = []
    #     for event in events:
    #         try:
    #             e = async_modio.EventType[event]
    #             enums.append(e.value)
    #         except KeyError:
    #             pass

    #     try:
    #         game = await self.bot.modio.get_game(game_id)
    #     except Exception as e:
    #         return await ctx.send(f":negative_squared_cross_mark: | {e}")

    #     self.bot.user_data[ctx.author.id]["subscriptions"][game_id] = enums
    #     await self.bot.query_executer("""INSERT INTO necrobot.Subscriptions VALUES ($1, $2) ON CONFLICT ON CONSTRAINT 
    #             subscriptions_pkey DO UPDATE SET events=$2""", ctx.author.id, ",".join(enums))

    #     await ctx.send(f":white_check_mark: | You have been subscribed to all valid events for mods of {game.name}")


    @modio.group(name="mod", invoke_without_command=True)
    async def modio_mod(self, ctx, *, value : Union[int, str] = None):
        """Used to obtain a mod from the game you set previously on that server. It is important to set
        a game before using this command, see the help for `modio game`

        {usage}

        __Example__
        `{pre}modio mod` - allows you to navigate a list of all the mods for the game you've set
        `{pre}modio mod 2` - shows you the mod with id number 2 if it exists for the game you've set
        `{pre}modio mod Lasers` - shows you the game that matches most closely the text 'Lasers' in their title 
        for the game you've set
        """
        if ctx.guild.id not in self.bot.games[ctx.author.id]:
            return await ctx.send(":negative_squared_cross_mark: | Please set a game for this server using n!modio game first.")

        game = self.bot.games[ctx.author.id][ctx.guild.id]
        if isinstance(game, int):
            game = await self.bot.modio.get_game(game)
            self.bot.games[ctx.author.id][ctx.guild.id] = game
        
        if value is None:
            mods = (await game.get_mods()).results

            def embed_maker(index):
                description = "\n".join([f"- {mod.name} ({mod.id})" for mod in mods[index*15:(index+1)*15]])
                embed = discord.Embed(title=f"{game.name} Mods", url=game.profile, description=description)
                embed.set_footer(text="Generated by Necrobot", icon_url=self.bot.user.avatar_url_as(format="png", size=128))

                return embed

            return await react_menu(ctx, len(mods)//15, embed_maker)

        if isinstance(value, str):
            fltr = async_modio.Filter().text(value)
            mods = (await game.get_mods(filter=fltr)).results
            if not mods:
                return await ctx.send(":negative_squared_cross_mark: | Couldn't find that mod")

            mod = process.extractOne(value, [x.name for x in mods])[0]
            mod = discord.utils.get(mods, name=mod)
        else:
            try:
                mod = await game.get_mod(value)
            except Exception as e:
                return await ctx.send(f":negative_squared_cross_mark: | {e}")

        events = (await mod.get_events()).results
        users = (await self.bot.modio.get_users(filter=async_modio.Filter().values_in(id=[x.user for x in events]))).results
        files = await mod.get_files(filter=async_modio.Filter().sort("id", reverse=True))

        def _embed_maker(index):
            embed = discord.Embed(title=mod.name, colour=discord.Colour(0x277b0), url=mod.profile, description=mod.summary)
            embed.set_author(name=mod.submitter.username, url=mod.submitter.profile, icon_url=mod.submitter.avatar.original)
            embed.set_footer(text="Generated by Necrobot", icon_url=self.bot.user.avatar_url_as(format="png", size=128))
            embed.set_author(name=mod.submitter.username, url=mod.submitter.profile, icon_url=mod.submitter.avatar.original)
            embed.set_thumbnail(url=mod.logo.original)
            if index == 0:                
                embed.add_field(name="Rating", value=f'''
                    - Rank: {mod.stats.rank}/{mod.stats.rank_total}
                    - Downloads: {mod.stats.downloads}
                    - Subscribers: {mod.stats.subscribers}
                    - :thumbsup: **{mod.stats.positive} / {mod.stats.negative}** :thumbdown:: {mod.stats.weighted}%
                    - {mod.stats.text} 
                ''')

                nl = "\n"
                embed.add_field(name="Info", value=f'''
                    - Maturity: {mod.maturity}
                    - Files: {files.pagination.total}{f"{nl}- Homepage: {mod.homepage}" if mod.homepage else ""}
                    - Download: [{mod.file.filename} v{mod.file.version}]({mod.file.url})

                ''')

                embed.add_field(name="Dates", value=f'''
                    - Published: {mod.date.strftime("%d %B %Y %H:%M:%S")}
                    - Last Updated: {mod.updated.strftime("%d %B %Y %H:%M:%S")}
                    - Live: {mod.live.strftime("%d %B %Y %H:%M:%S")}
                ''')

                embed.add_field(name="\u200b", value=" ".join([f'#{tag}' for tag in mod.tags.keys()]), inline=False)
            elif index > 0:
                for event in events[(index-1)*10:index*10]:
                    user = discord.utils.get(users, id=event.user)
                    embed.add_field(name=event.type.name.title().replace("_", " "), value=f'''
                        - Date: {event.date.strftime("%d %B %Y %H:%M:%S")}
                        - Change maker: [{user.username}]({user.profile})
                    ''')

            return embed

        await react_menu(ctx, (len(events)//10)+1, _embed_maker)

    @modio_mod.command(name="search")
    async def modio_mod_search(self, ctx, query):
        """Search for mods based on text query. Requires that a game has been set previously using `modio game`

        {usage}

        __Example__
        `{pre}modio mod search Lasers` - shows you a list of mods and their ids that have Lasers in their name  for
        the game you've set
        """
        if ctx.guild.id not in self.bot.games[ctx.author.id]:
            return await ctx.send(":negative_squared_cross_mark: | Please set a game for this server using n!modio game first.")

        game = self.bot.games[ctx.author.id][ctx.guild.id]
        if isinstance(game, int):
            game = await self.bot.modio.get_game(game)
            self.bot.games[ctx.author.id][ctx.guild.id] = game

        filtr = async_modio.Filter().text(query)
        mods = (await game.get_mods(filter=filtr)).results

        def embed_maker(index):
            description = "\n".join([f"- {mod.name} ({mod.id})" for mod in mods[index*15:(index+1)*15]])
            embed = discord.Embed(title=f"Games on mod.io", url="https://mod.io/", description=description)
            embed.set_footer(text="Generated by Necrobot", icon_url=self.bot.user.avatar_url_as(format="png", size=128))

            return embed

        return await react_menu(ctx, len(mods)//15, embed_maker)

def setup(bot):
    bot.add_cog(Modding(bot))
