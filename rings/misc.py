#!/usr/bin/python3.6
import discord
from discord.ext import commands
import datetime as d
from rings.utils.utils import react_menu
from discord.ext.commands.cooldowns import BucketType
import random
import asyncio
import json

class Misc():
    """A cog for all bunch commands that don't have a specific category they can stick to."""
    def __init__(self, bot):
        self.bot = bot
        with open("hunger_games_events.json", "r") as infile:
            self.events = json.load(infile)

    @commands.command()
    async def fight(self, ctx, *, tributes):
        """Takes in a list of tributes separated by `,` and simulates a hunger games based on Bransteele's Hunger Game Simulator. More than 
        one tribute needs to be supplied. Duplicate names will be supressed.

        {usage}

        __Example__
        `{pre}fight john , bob , emilia the trap` - starts a battle between tributes john, bob and emilia the trap"""
        tributes_list = list(set([x.strip() for x in tributes.split(",")]))
        if len(tributes_list) <2:
            await ctx.send(":negative_squared_cross_mark: | Please provide at least two names separated by `,`")
            return

        if len(tributes_list) > 32:
            await ctx.send(":negative_squared_cross_mark: | Please provide no more than 32 characters separated by `,`.")

        dead_list = []

        async def _phase_parser(event_name):
            idle_tributes = tributes_list.copy()
            # idle_events = self.events[event_name].copy()
            idle_events = self.events[event_name].copy() + ([event for event in self.events[event_name] if event["killed"] < 1] * 2) #three times the amount of not deadly events reduces possibility of picking deadly to 1/4th
            embed = discord.Embed(title="__**Hunger Games Simulator**__", colour=discord.Colour(0x277b0), description=f"{' - '.join(tributes_list)}\nPress :arrow_forward: to proceed")
            embed.set_footer(text="Generated by NecroBot", icon_url="https://cdn.discordapp.com/avatars/317619283377258497/a491c1fb5395e699148fcfed2ee755cf.jpg?size=128")

            done_list = list()
            while len(idle_tributes) > 0 and len(tributes_list) > 1:
                tributes = list()
                event = random.choice([event for event in idle_events if event["tributes"] <= len(idle_tributes) and len(event["killed"]) < len(tributes_list)])
                tributes = random.sample(idle_tributes, event["tributes"])
                idle_tributes = [x for x in idle_tributes if x not in tributes]
                if len(event["killed"]) > 0:
                    # idle_events.remove(event)
                    for killed in event["killed"]:
                        tribute = tributes[int(killed)-1]
                        del tributes_list[tributes_list.index(tribute)]
                        dead_list.append(tribute)

                format_dict = dict()
                for tribute in tributes:
                    format_dict["p"+str(tributes.index(tribute)+1)] = tribute
                try:
                    done_list.append(event["string"].format(**format_dict))
                except Exception as e:
                    channel = self.bot.get_channel(415169176693506048)
                    the_traceback = f"```py\n{traceback.format_exc()}\n```"
                    embed = discord.Embed(title="Fight Error", description=the_traceback, colour=discord.Colour(0x277b0))
                    embed.add_field(name='Error String', value=event["string"])
                    embed.add_field(name='Error Tribute Number', value=event["tributes"])
                    embed.add_field(name='Error Tribute Killed', value=event["killed"])
                    embed.add_field(name='Error Tributes', value=str(format_dict))
                    embed.set_footer(text="Generated by NecroBot", icon_url="https://cdn.discordapp.com/avatars/317619283377258497/a491c1fb5395e699148fcfed2ee755cf.jpg?size=128")
                    await channel.send(embed=embed)

                    if ctx.guild.id != 311630847969198082:
                        await ctx.send(":negative_squared_cross_mark: | Something unexpected went wrong, Necro's gonna get right to it. If you wish to know more on what went wrong you can join the support server: <https://discord.gg/Ape8bZt>")

                    return

            embed.add_field(name=event_name.title() + " " + str(day), value="\n".join(done_list))
            return embed            
        
        def check(reaction, user):
            return user == ctx.message.author and str(reaction.emoji) == "\N{BLACK RIGHT-POINTING TRIANGLE}" and msg.id == reaction.message.id

        day = 0
        embed = await _phase_parser("bloodbath")
        msg = await ctx.send(embed=embed)
        await msg.add_reaction("\N{BLACK RIGHT-POINTING TRIANGLE}")
        await self.bot.wait_for("reaction_add", check=check, timeout=600)

        async def _event_parser(event):
            embed = await _phase_parser(event)
            msg = await ctx.send(embed=embed)
            await msg.add_reaction("\N{BLACK RIGHT-POINTING TRIANGLE}")
            try:
                await self.bot.wait_for("reaction_add", check=check, timeout=600)
            except asyncio.TimeoutError as e:
                e.timer = 600
                await msg.clear_reactions()
                return self.bot.dispatch("command_error",ctx, e)

        while len(tributes_list) > 1:

            if day == 6:
                await _event_parser("feast")

            if len(tributes_list) >1: 
                await _event_parser("day")

            embed = discord.Embed(title="__**Dead Tributes**__", description="- " + "\n- ".join(dead_list) if len(dead_list) > 0 else "None")
            embed.set_footer(text="Generated by NecroBot", icon_url="https://cdn.discordapp.com/avatars/317619283377258497/a491c1fb5395e699148fcfed2ee755cf.jpg?size=128")
            msg = await ctx.send(embed=embed)
            await msg.add_reaction("\N{BLACK RIGHT-POINTING TRIANGLE}")
            try:
                await self.bot.wait_for("reaction_add", check=check, timeout=600)
            except asyncio.TimeoutError as e:
                    e.timer = 600
                    await msg.clear_reactions()
                    return self.bot.dispatch("command_error",ctx, e)
            del dead_list[:]

            if len(tributes_list) >1: 
                await _event_parser("night")

            day += 1

        await ctx.send(":tada:" + tributes_list[0] + " is the Winner! :tada:") 


    @commands.command()
    async def ow(self, ctx, username, region="eu", hero=None):
        """Creates a rich embed of the user's Owerwatch stats for PC only. You must parse through a valid Battle.NET Battle 
        Tag and optionally a region. You can also optionally parse in a hero's name to start the embeds at this hero.


        {usage}


        __Example__
        `{pre}ow FakeTag#1234 us` - generates an embed for user FakeTag#1234 in region us
        `{pre}ow FakeTag#0000 eu Winston` - generates an embed for user FakeTag#0000 in region eu starting at winston"""
        def get_a_hero_stat(hero_int):
            prog_list = ["__**"+hero.title()+"**__" if hero_list.index(hero) == hero_int else hero.title() for hero in hero_list]
            prog = " - ".join(prog_list)
            embed = discord.Embed(title="**" + username.replace("-", "#") + "** in region: " + region.upper(), colour=discord.Colour(0x277b0), description=prog)
            embed.set_footer(text="Generated by NecroBot", icon_url="https://cdn.discordapp.com/avatars/317619283377258497/a491c1fb5395e699148fcfed2ee755cf.jpg?size=128")

            s = data[region]["heroes"]["stats"]["quickplay"][hero_list[hero_int]]

            # general stats
            stats = list()
            to_find = ["deaths", "medals", "weapon_accuracy", "all_damage_done", "kill_streak_best", "time_played", "games_won"]
            for stat in to_find:
                try:
                    title = stat
                    if "most" in stat:
                        title = "Most " + stat.replace("most_", "")
                    stats.append(title.replace("_", " ").title() + ": " + "{0:.2f}".format(s["general_stats"][stat]))
                except KeyError:
                    pass

            embed.add_field(name="General Stats", value="-" + "\n-".join(stats), inline=False)

            # hero specific stats
            stats = list()
            for stat in s["hero_stats"]:
                title = stat
                if "most" in stat:
                    title = "Most " + stat.replace("most_", "")

                stats.append(title.replace("_", " ").title() + ": " + "{0:.2f}".format(s["hero_stats"][stat]))

            embed.add_field(name="Hero Stats", value="-" + "\n-".join(stats), inline=False)

            return embed

        async with ctx.message.channel.typing():
            username = username.replace("#", "-")
            headers = {"User-Agent":"NecroBot"}
            async with self.bot.session.get(f"https://owapi.net/api/v3/u/{username}/heroes", headers=headers) as r:
                try:
                    data = await r.json()
                except Exception as e:
                    print(await r.text())

            hero_list = list(data[region]["heroes"]["stats"]["quickplay"].keys())

            if not hero:
                hero_int = 0
            else:
                try:
                    hero_int = hero_list.index(hero.lower())
                except:
                    hero_int = 0

        await react_menu(self.bot, ctx, len(hero_list)-1, get_a_hero_stat, hero_int)


    @commands.group(invoke_without_command = True, aliases=["t","tags"])
    @commands.guild_only()
    async def tag(self, ctx, tag : str, *tag_args):
        """The base of the tag system. Also used to summoned tags through the [tag] argument.
        
        {usage}
        
        __Example__
        `{pre}tag necro` - prints the content of the tag 'necro' given that it exists on this server"""
        tag = tag.lower()
        arg_dict = dict()
        for arg in tag_args:
            arg_dict["arg"+str(tag_args.index(arg))] = arg

        if tag in self.bot.server_data[ctx.message.guild.id]["tags"]:
            tag_content = self.bot.server_data[ctx.message.guild.id]["tags"][tag]["content"]
            try:
                await ctx.channel.send(tag_content.format(server=ctx.message.guild, member=ctx.message.author, channel=ctx.message.channel, content=ctx.message.content,**arg_dict))
                self.bot.server_data[ctx.message.guild.id]["tags"][tag]["counter"] += 1
                await self.bot.query_executer("UPDATE necrobot.Tags SET uses = uses + 1 WHERE guild_id = $1 AND name = $2", ctx.guild.id, tag)
            except KeyError as e:
                await ctx.channel.send(f"Expecting the following argument: {e.args[0]}")
        else:
            await ctx.channel.send(":negative_squared_cross_mark: | This tag doesn't exist on this guild.")

    @tag.command(name="create",aliases=["add"])
    @commands.guild_only()
    async def tag_create(self, ctx, tag, *, content):
        """Assigns the [text] passed through to the tag named [name]. A few reserved keywords can be used to render the 
        tag dynamic.
        
        `{server.keyword}`
        Represents the server
        __Keywords__
        `name` - name of the server
        `id` - id of the server
        `created_at` - UTC tag of the creation time of the server
        `member_count` - returns the number of member
        
        `{member.keyword}`
        Represents the user that called the command
        __Keywords__
        `display_name` - the user nick if they have one, else the user's username
        `name` - the user's username
        `discriminator` - the user's discriminator (the 4 digits at the end)
        `joined_at` - specifies at what time the user joined the server
        `id` - user's id
        `mention` - mentions the user
        `created_at` - returns the creation time of the account
        
        `{channel.keyword}`
        Represents the channel the tag was summoned in
        __Keywords__
        `name` - channel name
        `id` - channel id
        `topic` - the channel's topic
        `mention` - returns a mention of the channel
        
        `{content}`
        Represents the content of the message
        
        `{argx}`
        Represents an argument you pass into the tag, replace x by the argument number starting from 0.
        E.g: `{pre}tag test [arg0] [arg1] [arg2]` 
        
        {usage}
        
        __Example__
        `{pre}tag add test1 {guild.name} is cool` - creates a tag that will replace `{guild.name}` by the name of the server it is summoned in
        `{pre}tag add test2 {arg0} {arg1}` - creates a tag that will replace arg0 and arg1 by the arguments passed
        """
        tag = tag.lower()
        if tag not in self.bot.server_data[ctx.message.guild.id]["tags"]:
            self.bot.server_data[ctx.message.guild.id]["tags"][tag] = {'content':content.replace("'", "\'").replace('"', '\"'),'owner':ctx.message.author.id, 'created':d.datetime.today().strftime("%d - %B - %Y %H:%M"), 'counter':0}
            await self.bot.query_executer("INSERT INTO necrobot.Tags VALUES ($1, $2, $3, $4, 0, $5);", ctx.guild.id, tag, content, ctx.author.id, d.datetime.today().strftime("%d - %B - %Y %H:%M"))
            await ctx.channel.send(":white_check_mark: | Tag " + tag + " added")
        else:
            await ctx.channel.send(":negative_squared_cross_mark: | A tag with this name already exists")

    @tag.command(name="del", aliases=["remove", "delete"])
    @commands.guild_only()
    async def tag_del(self, ctx, tag):
        """Deletes the tag [tag] if the users calling the command is its owner or a Server Admin (4+)
        
        {usage}
        
        __Example__
        `{pre}tag delete necro` - removes the tag 'necro' if you are the owner of if you have a permission level of 4+"""
        tag = tag.lower()
        if tag in self.bot.server_data[ctx.message.guild.id]["tags"]:
            if ctx.message.author.id == self.bot.server_data[ctx.message.guild.id]["tags"][tag]["owner"] or self.bot.user_data[ctx.message.author.id]["perms"][ctx.message.guild.id] >= 4:
                del self.bot.server_data[ctx.message.guild.id]["tags"][tag]
                await self.bot.query_executer("DELETE FROM necrobot.Tags WHERE guild_id = $1 AND name = $2;", ctx.guild.id, tag)
                await ctx.channel.send(f":white_check_mark: | Tag {tag} removed")
            else:
                await ctx.channel.send(":negative_squared_cross_mark: | You can't delete someone else's tag.")
        else:
            await ctx.channel.send(":negative_squared_cross_mark: | This tag doesn't exist.")

    @tag.command(name="edit", aliases=["modify"])
    @commands.guild_only()
    async def tag_edit(self, ctx, tag, *, text):
        """Replaces the content of [tag] with the [text] given. Basically works as a delete + create function but without the risk of losing the tag name ownership.
        
        {usage}
        
        __Example__
        `{pre}tag edit necro cool server` - replaces the content of the 'necro' tag with 'cool server'"""
        tag = tag.lower()
        if tag in self.bot.server_data[ctx.message.guild.id]["tags"]:
            if ctx.message.author.id == self.bot.server_data[ctx.message.guild.id]["tags"][tag]["owner"] or self.bot.user_data[ctx.message.author.id]["perms"][ctx.message.guild.id] >= 4:
                self.bot.server_data[ctx.message.guild.id]["tags"][tag]["content"] = text.replace("'", "\'").replace('"', '\"')
                await self.bot.query_executer("UPDATE necrobot.Tags SET content = $1 WHERE guild_id = $2 AND name = $3", text, ctx.guild.id, tag)
                await ctx.channel.send(":white_check_mark: | Tag " + tag + " modified")
            else:
                await ctx.channel.send(":negative_squared_cross_mark: | You can't edit someone else's tag.")
        else:
            await ctx.channel.send(":negative_squared_cross_mark: | This tag doesn't exist.")

    @tag.command(name="raw", aliases=["source"])
    @commands.guild_only()
    async def tag_raw(self, ctx, tag):
        """Returns the unformatted content of the tag [tag] so other users can see how it works.
        
        {usage}
        
        __Example__
        `{pre}raw necro` - prints the raw data of the 'necro' tag"""
        tag = tag.lower()
        if tag in self.bot.server_data[ctx.message.guild.id]["tags"]:
            await ctx.channel.send(f":notebook: | Source code for {tag}: ```{self.bot.server_data[ctx.message.guild.id]['tags'][tag]['content']}```")

    @tag.command(name="list")
    @commands.guild_only()
    async def tag_list(self, ctx):
        """Returns the list of tags present on the guild.
        
        {usage}"""
        tag_list = ", ".join(self.bot.server_data[ctx.message.guild.id]["tags"].keys()) if len(self.bot.server_data[ctx.message.guild.id]["tags"].keys()) > 0 else "None"
        await ctx.channel.send(f"Tags in {ctx.message.guild.name}: ```{tag_list}```")

    @tag.command(name="info")
    @commands.guild_only()
    async def tag_info(self, ctx, tag):
        """Returns information on the tag given.
        
        {usage}
        
        __Example__
        `{pre}tag info necro` - prints info for the tag 'necro'"""
        tag = tag.lower()
        tag_dict = self.bot.server_data[ctx.message.guild.id]["tags"][tag]
        embed = discord.Embed(title="__**" + tag + "**__", colour=discord.Colour(0x277b0), description="Created on " + tag_dict["created"])
        embed.add_field(name="Owner", value=ctx.message.guild.get_member(tag_dict["owner"]).mention)
        embed.add_field(name="Uses", value=tag_dict["counter"])
        embed.set_footer(text="Generated by NecroBot", icon_url="https://cdn.discordapp.com/avatars/317619283377258497/a491c1fb5395e699148fcfed2ee755cf.jpg?size=128")

        await ctx.channel.send(embed=embed)

    @commands.command()
    @commands.cooldown(3, 5, BucketType.channel)
    async def cat(self, ctx):
        """Posts a random cat picture from random.cat
        
        {usage}"""
        async with self.bot.session.get('http://aws.random.cat/meow') as r:
            try:
                res = await r.json()
                await ctx.send(embed=discord.Embed().set_image(url=res['file']))
                self.bot.cat_cache.append(res["file"])
            except aiohttp.ClientResponseError:
                if len(self.bot.cat_cache) > 0:
                    await ctx.send("API overloading, have a cached picture instead.", embed=discord.Embed(colour=discord.Colour(0x277b0)).set_image(url=random.choice(self.bot.cat_cache)))
                else:
                    await ctx.send(":negative_squared_cross_mark: | API overloading and cache empty, looks like you'll have to wait for now.")

    @commands.command()
    async def dog(self, ctx):
        """Posts a random dog picture from random.dog 
        
        {usage}"""
        async with aiohttp.ClientSession(connector=aiohttp.TCPConnector(verify_ssl=False)) as cs:
            async with cs.get('https://random.dog/woof.json') as r:
                res = await r.json()
                await ctx.send(embed=discord.Embed().set_image(url=res['url']))


def setup(bot):
    bot.add_cog(Misc(bot))