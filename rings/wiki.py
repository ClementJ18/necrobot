import discord
from discord.ext import commands

import re
import wikia
import urllib
from unwiki.unwiki import UnWiki
from mwclient import Site
from fuzzywuzzy import process

class Wiki():
    """A series of wikia-related commands. Used to search the biggest fan-made database of 
    information."""
    def __init__(self, bot):
        self.bot = bot

    @commands.command()
    async def edain(self, ctx, *, article : str = None):
        """Performs a search on the Edain Mod Wiki for the give article name. If an article is found then it will 
        return a rich embed of it, else it will return a list of a related articles and an embed of the first related article. 
        
        {usage}
        
        __Example__
        `{pre}edain Castellans` - print a rich embed of the Castellans page
        `{pre}edain Battering Ram` - prints a rich embed of the Battering Ram disambiguation page"""

        await self.personalised_wiki_check(ctx, "edain", article)

    @commands.group(invoke_without_command=True)
    async def aotr(self, ctx, *, article : str = None):
        """Performs a search on the Age of the Ring Wiki for the give article name. If an article is found then it will 
        return a rich embed of it, else it will return a list of a related articles and an embed of the first related article. 
        
        {usage}
        
        __Example__
        `{pre}edain Castellans` - print a rich embed of the Castellans page
        `{pre}edain Battering Ram` - prints a rich embed of the Battering Ram disambiguation page"""

        await self.personalised_wiki_check(ctx, "aotr", article)

    # @aotr.command(name="faq")
    async def aotr_faq(self, ctx, *, question : str = None):
        """Replies with up to 5 links from the Age of the Ring FAQ that have matched close to the initial question.

        {usage}

        __Example__
        `{pre}faq angmar faction` - will reply with links on why angmar isn't a faction
        """
        await self.faq_handler("aotr", ctx, question)

    async def personalised_wiki_check(self, ctx, wiki, article):
        if article is None:
            return await ctx.send(f"<https://{wiki}.wikia.com/>")

        msg = None
        try:
            article = wikia.page(wiki, article, preload=True)
        except wikia.wikia.WikiaError:
            try:
                search_list = wikia.search(wiki, article)
                msg = f"Article: **{article}** not found, returning first search result and the following search list: {search_list[1:]}"
                article = wikia.page(wiki.title(), search_list[0], preload=True)
            except (ValueError, IndexError):
                await ctx.send(":negative_squared_cross_mark: | Article not found, and search didn't return any results. Please try again with different terms.")
                return

        url = article.url.replace(" ", "_")
        embed = discord.Embed(title=article.title, colour=discord.Colour(0x277b0), url=url, description=article.section(article.sections[0]))

        try:
            embed.set_thumbnail(url=article.images[0]+"?size=400")
        except (IndexError, AttributeError, KeyError):
            pass

        if wiki == "edain":
            icon = "https://i.imgur.com/lPPQzRg.png"
        else:
            icon = "https://vignette.wikia.nocookie.net/aotr/images/6/64/Favicon.ico"

        embed.set_author(name=f"{wiki.title()} Wiki", url=f"http://{wiki}.wikia.com/", icon_url=icon)
        embed.set_footer(text="Generated by NecroBot", icon_url=self.bot.user.avatar_url_as(format="png", size=128))

        # if "Abilities" in article.sections:
        #     section = article.section("Abilities")
        #     if len(section) < 1024  and section:
        #         embed.add_field(name="Abilities", value=section, inline=False)
        #     else:
        #         for x in article.sections[1:]:
        #             section = article.section(x)
        #             if len(section) < 1024 and section:
        #                 embed.add_field(name=x, value=section, inline=False)
        #                 break
        # else:
        #     for x in article.sections[1:]:
        #         section = article.section(x)
        #         if len(section) < 1024 and section:
        #             embed.add_field(name=x, value=section, inline=False)
        #             break

        if article.related_pages:
            related_string = ""
            for related in article.related_pages[:3]:
                link = related.replace(')', '\)')
                related_string += f"- [{urllib.parse.unquote(related.split('/')[-1])}]({link})\n"

            embed.add_field(name="More Pages:", value=related_string, inline=False)

        # if wiki == "edain":
        #     embed.add_field(name="Quotes", value="Get all the sound quotes for units/heroes [here](https://edain.wikia.com/wiki/Edain_Mod_Soundsets)", inline=False)

        await ctx.send(msg, embed=embed)

    @commands.command()
    async def lotr(self, ctx, *, article_name : str = None):
        """Performs a search on the Tolkien Gateway for the give article name. If an article is found then it 
        will return a rich embed of it, else it will return a list of a related articles and an embed of the first related article. 

        {usage}

        __Example__
        `{pre}lotr Finrod` - creates an embed of Finrod Felagund
        `{pre}lotr Fellowship` - searches for 'Fellowship' and returns the first result"""
        if article_name is None:
            return await ctx.send(f"<http://tolkiengateway.net/>")

        msg = ""
        site = Site(("http", "tolkiengateway.net"))
        if site.pages[article_name].text() != "":
            article = site.pages[article_name]
        else:
            search_list = [x for x in site.raw_api("opensearch", search=article_name)[1]]
            if len(search_list) == 1:
                article = site.pages[search_list[0]]
            elif search_list:
                msg = f"Article: **{article_name}** not found, returning first search result and the following search list: {search_list[1:]}"
                article = site.pages[process.extract(article_name, search_list, 1, 0.5)[0][0]]
            else:
                await ctx.send(":negative_squared_cross_mark: | Article not found, and search didn't return any result. Please try again with different terms.")
                return           

        url = "http://tolkiengateway.net/wiki/" + article.name.replace(" ", "_")
        raw_desc = re.sub('<[^<]+?>', '', article.text(section=0))
        
        description = UnWiki(raw_desc).__str__()
        embed = discord.Embed(title=article.name, colour=discord.Colour(0x277b0), url=url, description=description[:2047])

        try:
            embed.set_thumbnail(url=list(article.images())[0].imageinfo["url"] + "?size=400")
        except (IndexError, AttributeError, KeyError):
            pass

        embed.set_author(name="Tolkien Gateway", url="http://tolkiengateway.net/", icon_url="https://i.imgur.com/I9Kx0kz.png")
        embed.set_footer(text="Generated by NecroBot", icon_url=self.bot.user.avatar_url_as(format="png", size=128))
        await ctx.send(msg, embed=embed)

    @commands.command()
    async def wiki(self, ctx, wiki : str, *, article_name : str = None):
        """Performs a search on the given wiki (if valid) for the given article name. If an article is found then it 
        will return a rich embed of it, else it will return a list of a related articles and an embed of the first related article. 

        {usage}

        __Example__
        `{pre}wiki disney Donald Duck` - creates a rich embed of the Donald Duck page
        `{pre}wiki transformers Optimus` - searches for the 'Optimus Page' and returns a list of search results and a
         rich embed of the first one."""
        if article_name is None:
            return await ctx.send(f"<https://{wiki}.wikia.com/>")

        msg = ""
        if wiki.lower() == "edain":
            await ctx.send(":negative_squared_cross_mark: | No. Use the `edain` command")
            return
        
        if wiki.lower() == "lotr":
            await ctx.send(":negative_squared_cross_mark: | No. Use the `lotr` command")
            return
            
        try:
            article = wikia.page(wiki, article_name)
        except wikia.wikia.WikiaError:
            try:
                search_list = wikia.search(wiki, article_name)
                msg = f"Article: **{article_name}** not found, returning first search result and the following search list: {search_list[1:]}"
                article = wikia.page(wiki, search_list[0])
            except ValueError:
                await ctx.send(":negative_squared_cross_mark: | Article not found or wiki not recognized, and search didn't return any result. Please try again with different terms.")
                return

        url = article.url.replace(" ", "_")

        embed = discord.Embed(title=article.title, colour=discord.Colour(0x277b0), url=url, description=article.section(article.sections[0]))

        try:
            embed.set_thumbnail(url=article.images[0]+"?size=400")
        except (IndexError, AttributeError, KeyError):
            pass
        embed.set_author(name=f"{article.sub_wikia.title()} Wiki", url=f"https://{article.sub_wikia}.wikia.com/")
        embed.set_footer(text="Generated by NecroBot", icon_url=self.bot.user.avatar_url_as(format="png", size=128))

        try:
            if article.related_pages:
                related = "- " + "\n- ".join(article.related_pages[:5])
                embed.add_field(name="More Pages:", value=related)
        except ValueError:
            pass
            
        await ctx.send(msg, embed=embed)

    @commands.command()
    async def faq(self, ctx, *, question : str = None):
        """Replies with up to 5 links from the Edain FAQ that have matched close to the initial question.

        {usage}

        __Example__
        `{pre}faq mirkwood faction` - will reply with links on why Mirkwood isn't its own faction
        """
        await self.faq_handler("edain", ctx, question)

    async def faq_handler(self, mod, ctx, question):
        ignored = set(("General Questions", "Faction Implementation Questions", "Hardcoded Bugs"))
        if not question:
            await ctx.send(f"https://{mod}.wikia.com/wiki/Frequently_Asked_Questions")
            return
            
        article = wikia.page(mod, "Frequently Asked Questions")
        matches = process.extract(question, set(article.sections) - ignored, limit=5)
        message = []

        for section in matches:
            if section[1] < 55:
                continue
            section = section[0]
            url = urllib.parse.quote(section.replace(" ", "_"), safe="/:").replace("%", ".")
            message.append(f"**{section}**")
            message.append(f"<{article.url.replace(' ', '_')}#{url}>")

        if not message:
            await ctx.send(":negative_squared_cross_mark: | Sorry, didn't find anything")
            return

        await ctx.send("\n".join(message))

def setup(bot):
    bot.add_cog(Wiki(bot))
