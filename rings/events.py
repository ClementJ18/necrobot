#!/usr/bin/python3.6
import discord
from discord.ext import commands

from rings.utils.config import *
from rings.utils.utils import has_goodbye, has_welcome, UPDATE_PERMS, UPDATE_FLOWERS

import io
import sys
import aiohttp
import asyncio
import asyncpg
import traceback
import time as t
from PIL import Image
from bs4 import BeautifulSoup
from datetime import timedelta

class NecroEvents():
    def __init__(self, bot):
        self.bot = bot
        self.bot._new_server = self._new_server
        self.bot._mu_auto_embed = self._mu_auto_embed
        self.bot._bmp_converter = self._bmp_converter
        self.bot._star_message = self._star_message
        self.bot.converter = self.converter
        self.bot.query_executer = self.query_executer
        self.bot.default_stats = self.default_stats
        self.bot.load_cache = self.load_cache
        self.bot.broadcast_task = self.bot.loop.create_task(self.broadcast())
        self.bot.status_task = self.bot.loop.create_task(self.rotation_status())

    def __unload(self):
        self.bot.broadcast_task.cancel()
        self.bot.status_task.cancel()

    def _new_server(self):
        return {
            "mute":"",
            "automod":"",
            "welcome-channel":"",
            "self-roles":[],
            "ignore-command":[],
            "ignore-automod":[],
            "welcome":"Welcome {member} to {server}!",
            "goodbye":"Leaving so soon? We\'ll miss you, {member}!",
            "tags":{},
            "prefix" :"",
            "broadcast-channel": "",
            "broadcast": "",
            "broadcast-time": 1,
            "disabled": [],
            "auto-role": "",
            "auto-role-timer": 0,
            "starboard-channel":"",
            "starboard-limit":5,
            "aliases":{}
        } 

    async def _mu_auto_embed(self, url, message):
        async with self.bot.session.get(url) as resp:
            soup = BeautifulSoup(await resp.text(), "html.parser")

        try:
            header = list(soup.find_all("h3", class_="catbg")[-1].stripped_strings)[1].replace("Thema: ", "").split(" \xa0")
            title = header[0]
            read = header[1].replace("Gelesen", "Read**").replace("mal", "**times").replace("(", "").replace(")","")
        except IndexError:
            return

        op = soup.find("div", class_="poster")
        bot_ico = "https://cdn.discordapp.com/avatars/317619283377258497/a491c1fb5395e699148fcfed2ee755cf.jpg?size=128"
        board = [x.a.string for x in soup.find("div", class_="navigate_section").ul.find_all("li") if "board" in x.a["href"]][0]

        embed = discord.Embed(title=title, url=url, colour=discord.Colour(0x277b0), description=f"Some information on the thread that was linked \n -Board: **{board}** \n -{read}")
        if op.a is not None:
            embed.set_author(name=f"OP: {op.a.string}", url=op.a["href"], icon_url=op.find("img", class_="avatar")["src"] if op.find("img", class_="avatar") is not None else bot_ico)
        else:
            embed.set_author(name=f"OP: {list(op.stripped_strings)[0]}")

        embed.set_footer(text="Generated by NecroBot", icon_url=bot_ico)

        await message.channel.send("Oh. That's a little bare. Here, let me embed that for you.", embed=embed)

    async def _bmp_converter(self, message):
        attachment = message.attachments[0]
        f = io.BytesIO()
        await attachment.save(f)

        with Image.open(f) as im:
            output_buffer = io.BytesIO()
            im.save(output_buffer, "png")
            output_buffer.seek(0)
            ifile = discord.File(filename="converted.png", fp=output_buffer)
        
        await message.channel.send(file=ifile)

    async def _star_message(self, message):
        embed = discord.Embed(colour=discord.Colour(0x277b0), description = message.content)
        embed.set_author(name=message.author.display_name, icon_url=message.author.avatar_url.replace("webp","jpg"))
        embed.set_footer(text="Generated by NecroBot", icon_url="https://cdn.discordapp.com/avatars/317619283377258497/a491c1fb5395e699148fcfed2ee755cf.jpg?size=128")
        if message.embeds:
            data = message.embeds[0]
            if data.type == 'image':
                embed.set_image(url=data.url)

        if message.attachments:
            file = message.attachments[0]
            if file.url.lower().endswith(('png', 'jpeg', 'jpg', 'gif', 'webp')):
                embed.set_image(url=file.url)
            else:
                embed.add_field(name='Attachment', value=f'[{file.filename}]({file.url})', inline=False)

        msg = await self.bot.get_channel(self.bot.server_data[message.guild.id]["starboard-channel"]).send(content=f"In {message.channel.mention}", embed=embed)
        
        if message.id not in self.bot.starred:
            self.bot.starred.append(message.id)
            await self.bot.query_executer("INSERT INTO necrobot.Starred VALUES ($1, $2, $3);", message.id, msg.id, msg.guild.id)

    def converter(self, time):
        days = time.rpartition("d")[0]
        if days == "":
            days = 0

        time = time.rpartition("d")[2]

        hours = time.rpartition("h")[0]
        if hours == "":
            hours = 0

        time = time.rpartition("h")[2]

        minutes = time.rpartition("m")[0]
        if minutes == "":
            minutes = 0

        time = time.rpartition("m")[2]

        seconds = time.rpartition("s")[0]
        if seconds == "":
            seconds = 0

        return int(seconds) + (int(minutes) * 60) + (int(hours) * 3600) + (int(days) * 86400)
               
    async def broadcast(self):
        await self.bot.wait_until_ready()
        time = 3600
        while not self.bot.is_closed():
            if self.bot.counter >= 24:
                self.bot.counter = 0

            await asyncio.sleep(time) # task runs every hour
            start = t.time()
            self.bot.counter += 1

            def guild_check(guild):
                if self.bot.server_data[guild]["broadcast-time"] < 1:
                    return False

                if self.bot.get_guild(guild) is None:
                    return False

                if self.bot.get_channel(self.bot.server_data[guild]["broadcast-channel"]) is None:
                    return False
                    
                return self.bot.get_channel(self.bot.server_data[guild]["broadcast-channel"]) is not None and self.bot.server_data[guild]["broadcast"] != "" and (self.bot.counter % self.bot.server_data[guild]["broadcast-time"]) == 0

            broadcast_guilds = [guild for guild in self.bot.server_data if guild_check(guild)]

            for guild in broadcast_guilds:
                try:
                    channel = self.bot.get_channel(self.bot.server_data[guild]["broadcast-channel"])
                    await channel.send(self.bot.server_data[guild]["broadcast"])
                except Exception as e:
                    raise Exception(f"Broadcast error with guild {guild}\n{e}")

            time = 3600 - round(t.time() - start)


    async def rotation_status(self):
        await self.bot.wait_until_ready()
        try:
            while not self.bot.is_closed():
                await asyncio.sleep(3600)
                status = self.bot.statuses.pop(0)
                self.bot.statuses.append(status)
                await self.bot.change_presence(activity=discord.Game(name=status.format(guild=len(self.bot.guilds), members=len(self.bot.users))))
        except Exception as e:
            self.bot.dispatch("error", e)

    async def load_cache(self):        
        self.bot.pool = await asyncpg.create_pool(database="postgres", user="postgres", password=dbpass)
        channel = self.bot.get_channel(318465643420712962)
        msg = await channel.send("**Initiating Bot**")
        for guild in self.bot.guilds:
            if guild.id not in self.bot.server_data:
                    self.bot.server_data[guild.id] = self.bot._new_server()
                    await self.bot.query_executer("INSERT INTO necrobot.Guilds VALUES($1, 0, 0, 0, 'Welcome {member} to {server}!', 'Leaving so soon? We''ll miss you, {member}!)', '', 0, '', 1, 0, 5, 0);", guild.id)
        await msg.edit(content="All servers checked")

        members = self.bot.get_all_members()
        for member in members:
            await self.bot.default_stats(member, member.guild)
            
        await msg.edit(content="All members checked")
        await msg.edit(content="**Bot Online**")

        await self.bot.change_presence(activity=discord.Game(name="n!help for help"))

    async def query_executer(self, query, *args):
        conn = await self.bot.pool.acquire()
        result = []
        try:
            if query.startswith("SELECT"):
                result = await conn.fetch(query, *args)
            else:
                await conn.execute(query, *args)
        except Exception as error:
            channel = self.bot.get_channel(415169176693506048)
            the_traceback = f"```py\n{' '.join(traceback.format_exception(type(error), error, error.__traceback__, chain=False))}\n```"
            embed = discord.Embed(title="DB Error", description=the_traceback, colour=discord.Colour(0x277b0))
            embed.add_field(name='Event', value=error)
            embed.add_field(name="Query", value=query)
            embed.add_field(name="Arguments", value=args)
            embed.set_footer(text="Generated by NecroBot", icon_url="https://cdn.discordapp.com/avatars/317619283377258497/a491c1fb5395e699148fcfed2ee755cf.jpg?size=128")
            await channel.send(embed=embed)
            
        finally:
            await self.bot.pool.release(conn)
            return result
            
    async def default_stats(self, member, guild):
        if member.id not in self.bot.user_data:
            self.bot.user_data[member.id] = {'money': 200, 'daily': '', 'title': '', 'exp': 0, 'perms': {}, 'badges':[], "waifu":{}, "warnings": {}, 'places':{"1":"", "2":"", "3":"", "4":"", "5":"", "6":"", "7":"", "8":""}, "tutorial": False}
            await self.bot.query_executer("INSERT INTO necrobot.Users VALUES ($1, 200, 0, '          ', '', '', 'False');", member.id)
            await self.bot.query_executer("""INSERT INTO necrobot.Badges VALUES ($1, 1, ''), ($1, 2, ''), ($1, 3, ''), ($1, 4, ''), ($1, 5, ''), ($1, 6, ''), ($1, 7, ''), ($1, 8, '');""", member.id)

        if isinstance(member, discord.User):
            member = guild.get_member(member.id)

        if guild.id not in self.bot.user_data[member.id]["perms"]:
            if any(self.bot.user_data[member.id]["perms"][x] == 7 for x in self.bot.user_data[member.id]["perms"]):
                self.bot.user_data[member.id]["perms"][guild.id] = 7
            elif any(self.bot.user_data[member.id]["perms"][x] == 6 for x in self.bot.user_data[member.id]["perms"]):
                self.bot.user_data[member.id]["perms"][guild.id] = 6
            elif member.id == guild.owner.id:
                self.bot.user_data[member.id]["perms"][guild.id] = 5
            elif member.guild_permissions.administrator:
                self.bot.user_data[member.id]["perms"][guild.id] = 4
            else:
                self.bot.user_data[member.id]["perms"][guild.id] = 0

            await self.bot.query_executer("INSERT INTO necrobot.Permissions VALUES ($1,$2,$3);", guild.id, member.id, self.bot.user_data[member.id]["perms"][guild.id])

        if guild.id not in self.bot.user_data[member.id]["waifu"]:
            self.bot.user_data[member.id]["waifu"][guild.id] = {"waifu-value":50, "waifu-claimer":"", "affinity":"", "heart-changes":0, "divorces":0, "waifus":[], "flowers":0, "gifts":{}}
            await self.bot.query_executer("INSERT INTO necrobot.Waifu VALUES ($1,$2,50,0,0,0,0,0);", member.id, guild.id)


    async def on_resumed(self):
        channel = self.bot.get_channel(318465643420712962)
        await channel.send("**Bot Resumed**")

    async def on_command_error(self, ctx, error):
        """Catches error and sends a message to the user that caused the error with a helpful message."""
        channel = ctx.message.channel
        try:
            if ctx.command.name in self.bot.server_data[ctx.message.guild.id]["disabled"] and ctx.prefix not in self.bot.admin_prefixes:
                await ctx.send(f":negative_squared_cross_mark: | Command {ctx.command.name} cannot be used on this server.", delete_after=10)
                await ctx.message.delete()
                return
        except AttributeError:
            pass

        if isinstance(error, commands.MissingRequiredArgument):
            await channel.send(f":negative_squared_cross_mark: | Missing required argument: `{error.param.name}`! Check help guide with `n!help {ctx.command.qualified_name}`", delete_after=10)
            #this can be used to print *all* the missing arguments (bit hacky tho)
            # index = list(ctx.command.clean_params.keys()).index(error.param.name)
            # missing = list(ctx.command.clean_params.values())[index:]
            # print(f"missing following: {", ".join([x.name for x in missing])}")
        elif isinstance(error, commands.CheckFailure):
            await channel.send(f":negative_squared_cross_mark: | **{error}**", delete_after=10)
        elif isinstance(error, commands.CommandOnCooldown):
            retry_after = str(timedelta(seconds=error.retry_after)).partition(".")[0].replace(":", "{}").format("hours, ", "minutes and ")
            await channel.send(f":negative_squared_cross_mark: | This command is on cooldown, retry after **{retry_after}seconds**", delete_after=10)
        elif isinstance(error, commands.NoPrivateMessage):
            await channel.send(":negative_squared_cross_mark: | This command cannot be used in private messages.", delete_after=10)
        elif isinstance(error, commands.DisabledCommand):
            await channel.send(":negative_squared_cross_mark: | This command is disabled and cannot be used for now.", delete_after=10)
        elif isinstance(error, commands.BadArgument) or isinstance(error, commands.BadUnionArgument):
            await channel.send(f":negative_squared_cross_mark: | Following error with passed arguments: **{error}**", delete_after=10)
        elif isinstance(error, asyncio.TimeoutError):
            if not hasattr(error, "timer"):
                return

            retry_after = str(timedelta(seconds=error.timer)).partition(".")[0].replace(":", "{}").format("hours, ", "minutes and ")
            await channel.send(f":negative_squared_cross_mark: | You took too long to reply, please reply within {retry_after}seconds next time", delete_after=10)
        elif isinstance(error, commands.CommandInvokeError):
            if "Forbidden" in error.args[0]:
                await channel.send(":negative_squared_cross_mark: | Something went wrong, check my permission level, it seems I'm not allowed to do that on your server.", delete_after=10)
                return

            channel = self.bot.get_channel(415169176693506048)
            the_traceback = "```py\n" + " ".join(traceback.format_exception(type(error), error, error.__traceback__, chain=True)) + "\n```"
            embed = discord.Embed(title="Command Error", description=the_traceback, colour=discord.Colour(0x277b0))
            embed.set_footer(text="Generated by NecroBot", icon_url="https://cdn.discordapp.com/avatars/317619283377258497/a491c1fb5395e699148fcfed2ee755cf.jpg?size=128")
            embed.add_field(name="Command", value=ctx.command.name)
            embed.add_field(name="Author", value=ctx.author.mention)
            embed.add_field(name="Location", value=f"**Guild:** {ctx.guild.name} ({ctx.guild.id}) \n**Channel:** {ctx.channel.name} ({ctx.channel.id})")
            embed.add_field(name="Message", value=ctx.message.content, inline=False)
            try:
                await channel.send(embed=embed)
            except discord.HTTPException:
                print(f'Bot: Ignoring exception in command {ctx.command}:', file=sys.stderr)
                traceback.print_exception(type(error), error, error.__traceback__, file=sys.stderr)
            
            if ctx.guild.id != 311630847969198082:
                await ctx.send(":negative_squared_cross_mark: | Something unexpected went wrong, Necro's gonna get right to it. If you wish to know more on what went wrong you can join the support server, the invite is in the `about` command.", delete_after=10)
                
    async def on_guild_join(self, guild):
        if guild.id in self.bot.settings["blacklist"]:
            await guild.leave()
            return

        if guild.id not in self.bot.server_data:
            self.bot.server_data[guild.id] = self.bot._new_server()
            await self.bot.query_executer("INSERT INTO necrobot.Guilds VALUES($1, 0, 0, 0, 'Welcome {member} to {server}!', 'Leaving so soon? We''ll miss you, {member}!)', '', 0, '', 1, 0, 5, 0, 0);", guild.id)

        for member in guild.members:
            await self.bot.default_stats(member, guild)

        await guild.owner.send(embed=self.bot.tutorial_e)

    async def on_message_delete(self, message):
        if message.id in self.bot.ignored_messages:
            self.bot.ignored_messages.remove(message.id)
            return
            
        if isinstance(message.channel, discord.DMChannel) or self.bot.server_data[message.guild.id]["automod"] == "" or message.author.bot:
            return

        role_id = [role.id for role in message.author.roles]
        if message.author.id not in self.bot.server_data[message.guild.id]["ignore-automod"] and message.channel.id not in self.bot.server_data[message.guild.id]["ignore-automod"] and not any(x in role_id for x in self.bot.server_data[message.guild.id]["ignore-automod"]):
            if not message.content:
                message.content = "\U0000200b"

            embed = discord.Embed(title="Message Deleted", description=message.content, colour=discord.Colour(0x277b0))
            embed.set_author(name=message.author, icon_url= message.author.avatar_url)
            embed.set_footer(text="Generated by NecroBot", icon_url="https://cdn.discordapp.com/avatars/317619283377258497/a491c1fb5395e699148fcfed2ee755cf.jpg?size=128")
            embed.add_field(name="Info", value="In " + message.channel.mention + " by " + message.author.mention)
            embed.add_field(name="Attachment?", value="Yes" if message.attachments else "No", inline=False)
            channel = self.bot.get_channel(self.bot.server_data[message.guild.id]["automod"])
            await channel.send(embed=embed)

    async def on_message_edit(self, before, after):
        if isinstance(before.channel, discord.DMChannel) or self.bot.server_data[before.guild.id]["automod"] == "":
            return

        if before.author.bot or before.content == after.content:
            return

        role_id = [role.id for role in before.author.roles]
        if before.author.id not in self.bot.server_data[before.guild.id]["ignore-automod"] and before.channel.id not in self.bot.server_data[before.guild.id]["ignore-automod"] and not any(x in role_id for x in self.bot.server_data[before.guild.id]["ignore-automod"]):
            embed = discord.Embed(title="Message Edited", description="In " + before.channel.mention + " by " + before.author.mention, colour=discord.Colour(0x277b0))
            if not after.content:
                after.content = "\U0000200b"

            embed.set_author(name=before.author, icon_url= before.author.avatar_url)
            embed.set_footer(text="Generated by NecroBot", icon_url="https://cdn.discordapp.com/avatars/317619283377258497/a491c1fb5395e699148fcfed2ee755cf.jpg?size=128")
            embed.add_field(name="Before", value=before.content if len(before.content) < 1024 else before.content[1020:] + "...", inline=False)
            embed.add_field(name="After", value=after.content if len(after.content) < 1024 else after.content[1020:] + "...", inline=False)
            channel = self.bot.get_channel(self.bot.server_data[before.guild.id]["automod"])
            await channel.send(embed=embed)

    async def on_command(self, ctx):
        try:
            can_run = str(await ctx.command.can_run(ctx))
        except:
            can_run = "False"

        if not ctx.guild:
            guildname = "DM"
            guildid = None
        else:
            guildname = ctx.guild.name
            guildid = ctx.guild.id

        await self.bot.query_executer("INSERT INTO necrobot.Logs (user_id, username, command, guild_id, guildname, message, can_run) VALUES($1,$2,$3,$4,$5,$6,$7);", ctx.author.id, ctx.author.name, ctx.command.name, guildid, guildname, ctx.message.content, can_run)

    async def on_member_join(self, member):
        await self.bot.default_stats(member, member.guild)

        if member.bot:
            return

        if has_welcome(self.bot, member):
            channel = self.bot.get_channel(self.bot.server_data[member.guild.id]["welcome-channel"])
            message = self.bot.server_data[member.guild.id]["welcome"]
            if member.id in self.bot.settings["blacklist"]:
                await channel.send(":eight_pointed_black_star: | **You are not welcome here, disturber of the peace**")
            else:
                await channel.send(message.format(member=member, server=member.guild.name))

        if not self.bot.server_data[member.guild.id]["auto-role"] == "":
            role = discord.utils.get(member.guild.roles, id=self.bot.server_data[member.guild.id]["auto-role"])
            await member.add_roles(role)

            if self.bot.server_data[member.guild.id]["auto-role-timer"] > 0:
                await asyncio.sleep(self.bot.server_data[member.guild.id]["auto-role-timer"])
                try:
                    await member.remove_roles(role)
                except:
                    pass

    async def on_member_remove(self, member):
        if self.bot.user_data[member.id]["perms"][member.guild.id] < 6:
            self.bot.user_data[member.id]["perms"][member.guild.id] = 0
            await self.bot.query_executer(UPDATE_PERMS, member.guild.id, member.id)

        if has_goodbye(self.bot, member):
            channel = self.bot.get_channel(self.bot.server_data[member.guild.id]["welcome-channel"])
            message = self.bot.server_data[member.guild.id]["goodbye"]

            if member.id in self.bot.settings["blacklist"]:
                await channel.send(":eight_pointed_black_star: | **...**")
            else:
                await channel.send(message.format(member=member, server=member.guild.name))

    async def on_reaction_add(self, reaction, user):
        if user.id in self.bot.settings["blacklist"]:
            return
            
        if isinstance(user, discord.User) and reaction.emoji == "\N{WASTEBASKET}" and reaction.message.author == self.bot.user:
            await reaction.message.delete()
            return            

        if reaction.emoji == "\N{CHERRY BLOSSOM}" and reaction.message.id in self.bot.events:
            if user.id in self.bot.events[reaction.message.id]["users"]:
                return

            self.bot.events[reaction.message.id]["users"].append(user.id)
            self.bot.user_data[user.id]["waifu"][reaction.message.guild.id]["flowers"] += self.bot.events[reaction.message.id]["amount"]
            await self.bot.query_executer(UPDATE_FLOWERS, self.bot.user_data[user.id]["waifu"][reaction.message.guild.id]["flowers"], user.id, reaction.message.guild.id)

        if self.bot.server_data[user.guild.id]["starboard-channel"] == "":
            return

        if reaction.message.channel.id == self.bot.server_data[user.guild.id]["starboard-channel"]:
            return

        if reaction.message.id in self.bot.starred:
            return

        if reaction.emoji == "\N{WHITE MEDIUM STAR}" and reaction.count >= self.bot.server_data[user.guild.id]["starboard-limit"]:
            users = await reaction.users().flatten()
            try:
                users.remove(reaction.message.author)
            except ValueError:
                pass

            if len(users) >=  self.bot.server_data[user.guild.id]["starboard-limit"]:
                await self.bot._star_message(reaction.message)        

def setup(bot):
    bot.add_cog(NecroEvents(bot))
