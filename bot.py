import discord
from discord.ext import commands

from rings.utils.help import NecroBotHelpFormatter
from rings.utils.config import token, dbpass
from rings.utils.db import db_gen

import random
import sys
import time as t
import asyncio
import traceback
import re
from bs4 import BeautifulSoup
import aiohttp
from PIL import Image
import os
import functools
import psycopg2
import asyncpg
import json
import copy
import io

async def get_pre(bot, message):
    if not isinstance(message.channel, discord.DMChannel):
        guild_pre = bot.server_data[message.guild.id]["prefix"]
        if guild_pre != "":
            return [guild_pre, "n@"]

    return bot.prefixes

extensions = [
    "hunger",
    "animals",
    "social",
    "wiki",
    "modding",
    "support",
    "utilities",
    "moderation",
    "profile",
    "tags",
    "server",
    "admin",
    "decisions",
    "economy",
    "events",
    "waifu",
    "gamestats"
]

replyList = [
    "*yawn* What can I do fo... *yawn*... for you?", 
    "NecroBot do that, NecroBot do this, never NecroBot how are y... Oh, hey how can I help?",
    "I wonder how other bots are treated :thinking: Do they also put up with their owners' terrible coding habits?",
    "Second sight ordains it! I mean sure..."
    ]

class NecroBot(commands.Bot):
    def __init__(self):
        super().__init__(command_prefix=get_pre, description="A bot for moderation and LOTR", formatter=NecroBotHelpFormatter(), case_insensitive=True, owner_id=241942232867799040, activity=discord.Game(name="Bot booting...", type=0))
        self.uptime_start = t.time()
        self.user_data, self.server_data = db_gen()

        self.ERROR_LOG = 351356683231952897
        self.version = 1.5
        self.prefixes = ["n!", "N!", "n@"]
        self.admin_prefixes = ["n@", "N@"]
        self.new_commands = ["convert", "blacklist", "ttt", "star", "game", "tutorial", "news"]

        # self.bg_task = self.loop.create_task(self.hourly_task())
        self.broadcast_task = self.loop.create_task(self.broadcast())
        self.session = aiohttp.ClientSession(loop=self.loop)
        
        self.cat_cache = []
        self.starred = []
        self.events = {}

        @self.check
        def disabled_check(ctx):
            disabled = self.server_data[ctx.message.guild.id]["disabled"]
            if ctx.guild is None:
                return True

            if ((ctx.command.name in disabled or ctx.command.cog_name in disabled) and ctx.prefix != "n@"):
                raise commands.CheckFailure("This command/cog has been disabled")

            return True
                
        self.add_check(disabled_check)

        with open("rings/utils/data/settings.json", "rb") as infile:
            self.settings = json.load(infile)

        embed = discord.Embed(title="NecroBot Tutorial", description="A helpful tutorial section for a more advanced overview on NecroBot's system. This should give users a more indepth overview on certain specifics features of it. It's a lot of information to take in at once, so feel free to read it bit by bit, and if you have any more questions you can join the official support server. Use `n!about` for an invite link.", colour=discord.Colour(0x277b0))
        embed.set_footer(text="Generated by NecroBot", icon_url="https://cdn.discordapp.com/avatars/317619283377258497/a491c1fb5395e699148fcfed2ee755cf.jpg?size=128")
        embed.add_field(name="The Permision System", value="The permissions system is the heart of NecroBot, it dictates what users can use which set of commands, however unlike other bots, it is not tied to a user's server permissions. This means that permissions must be manually assigned using the `perms` command. The server owner and users with administrator rights are automatically given level 5 and 4 accordingly but users needing permission level 3 and below will need manual assignment. When a user leaves a server their permission level is reset to 0, when a NecroBot Admin joins their level is automatically set to 6. All users with level 4 and above can use this commad but they can only set the permission level of other users to a number below their own.")
        embed.add_field(name="Guild-Specific vs Discord-Wide Data", value="Profile data on necrobot is separated into two categories: data which depends on which server you call the command in (Server-Specific) and data which remains the same regardless of the server (Discord-Wide). Such things are money, badges and exp are discord wide and therefore are harder to obtain. Things like waifus, warnings and permissions are user server-specific data and therefore they can often be modified by a server's authorities. Other-server speccific data are things like the automoderation list, the starboard channel, ect... The thing to keep in mind is that server specific data can be edited by server authorities while discord-wide data can only be edited at the discretion of NecroBot admins.")
        embed.add_field(name="Settings", value="The settings command is the command to customize how NecroBot behaves on your server. It includes a lot of subcommands which each cater to certain part so make sure to check out the help guide. In addition, several other commands allow you to decide how much NecroBot sees and does and how much users can use it. For example, the `disable` command allows to disable specific commands on the entire server, the `automod` command allows you to pick which channel/role/user is tracked by the bot automoderation and the `ignore` command allows you to pick who can and can't use the bot's features. Check out the Moderation and Server cogs for more info.")
        embed.add_field(name="Feedback & Suggestions", value="Necro's always looking to improve his bot and has therefore created several ways to communicate feedback. You can join the official support server and drop your suggestion there (do `n!about` to get an invite link). You can also use the `report` command, just use it anywhere and add your message after the command, it'll be sent directly to the server. Finally, you can also contact Necro#6714 with your ideas. All spam/nsfw will be deleted and offenders will be blocked from the bot.")
        self.tutorial_e = embed


    # *****************************************************************************************************************
    #  Internal Function
    # *****************************************************************************************************************
    def _new_server(self):
        return {"mute":"","automod":"","welcome-channel":"", "self-roles":[],"ignore-command":[],"ignore-automod":[],"welcome":"Welcome {member} to {server}!","goodbye":"Leaving so soon? We\'ll miss you, {member}!","tags":{}, "prefix" : "", "broadcast-channel": "", "broadcast": "", "broadcast-time": 1, "disabled": [], "auto-role": "", "auto-role-timer": 0, "starboard-channel":"", "starboard-limit":5} 
    
    def _startswith_prefix(self, message):
        if self.server_data[message.guild.id]["prefix"] != "" and message.content.startswith(self.server_data[message.guild.id]["prefix"]):
            return True

        if message.content.startswith(tuple(self.prefixes)):
            return True

        return False

    def _is_allowed_summon(self, message):
        role_id = [role.id for role in message.author.roles]
        user_id = message.author.id
        channel_id = message.channel.id
        if self.user_data[user_id]["perms"][message.guild.id] >= 4 and message.content.startswith("n@"):
            return True

        if user_id in self.server_data[message.guild.id]["ignore-command"] or channel_id in self.server_data[message.guild.id]["ignore-command"] or any(x in role_id for x in self.server_data[message.guild.id]["ignore-command"]):
            return False

        return True

    async def _mu_auto_embed(self, url, message):
        async with self.session.get(url) as resp:
            soup = BeautifulSoup(await resp.text(), "html.parser")

        try:
            header = list(soup.find_all("h3", class_="catbg")[-1].stripped_strings)[1].replace("Thema: ", "").split(" \xa0")
            title = header[0]
            read = header[1].replace("Gelesen", "Read**").replace("mal", "**times").replace("(", "").replace(")","")
        except IndexError:
            return

        op = soup.find("div", class_="poster")
        bot_ico = "https://cdn.discordapp.com/avatars/317619283377258497/a491c1fb5395e699148fcfed2ee755cf.jpg?size=128"
        board = [x.a.string for x in soup.find("div", class_="navigate_section").ul.find_all("li") if "board" in x.a["href"]][0]

        embed = discord.Embed(title=title, url=url, colour=discord.Colour(0x277b0), description=f"Some information on the thread that was linked \n -Board: **{board}** \n -{read}")
        if op.a is not None:
            embed.set_author(name="OP: " + op.a.string, url=op.a["href"], icon_url=op.find("img", class_="avatar")["src"] if op.find("img", class_="avatar") is not None else bot_ico)
        else:
            embed.set_author(name="OP: " + list(op.stripped_strings)[0])

        embed.set_footer(text="Generated by NecroBot", icon_url=bot_ico)

        await message.channel.send("Oh. That's a little bare. Here, let me embed that for you.", embed=embed)

    async def _bmp_converter(self, message):
        attachment = message.attachments[0]
        f = io.BytesIO()
        await attachment.save(f)

        with Image.open(f) as im:
            output_buffer = io.BytesIO()
            im.save(output_buffer, "png")
            output_buffer.seek(0)
            ifile = discord.File(filename="converted.png", fp=output_buffer)
        
        await message.channel.send(file=ifile)

    async def _star_message(self, message):
        embed = discord.Embed(colour=discord.Colour(0x277b0), description = message.content)
        embed.set_author(name=message.author.display_name, icon_url=message.author.avatar_url.replace("webp","jpg"))
        embed.set_footer(text="Generated by NecroBot", icon_url="https://cdn.discordapp.com/avatars/317619283377258497/a491c1fb5395e699148fcfed2ee755cf.jpg?size=128")
        if message.embeds:
            data = message.embeds[0]
            if data.type == 'image':
                embed.set_image(url=data.url)

        if message.attachments:
            file = message.attachments[0]
            if file.url.lower().endswith(('png', 'jpeg', 'jpg', 'gif', 'webp')):
                embed.set_image(url=file.url)
            else:
                embed.add_field(name='Attachment', value=f'[{file.filename}]({file.url})', inline=False)
        
        await self.get_channel(self.server_data[message.guild.id]["starboard-channel"]).send(content=f"In {message.channel.mention}", embed=embed)
        self.starred.append(message.id)

    def converter(self, time):
        days = time.rpartition("d")[0]
        if days == "":
            days = 0

        time = time.rpartition("d")[2]

        hours = time.rpartition("h")[0]
        if hours == "":
            hours = 0

        time = time.rpartition("h")[2]

        minutes = time.rpartition("m")[0]
        if minutes == "":
            minutes = 0

        time = time.rpartition("m")[2]

        seconds = time.rpartition("s")[0]
        if seconds == "":
            seconds = 0

        return int(seconds) + (int(minutes) * 60) + (int(hours) * 3600) + (int(days) * 86400)


    # *****************************************************************************************************************
    #  Background Tasks
    # *****************************************************************************************************************
    async def _save(self):
        #upload user cache
        cached_users = copy.deepcopy(self.user_data)
        for user in cached_users:
            u = cached_users[user]
            await self.query_executer("UPDATE necrobot.Users SET necroins = $1, exp = $2, badges = $4 WHERE user_id = $3;",
                            u["money"], u["exp"], user, ",".join(u["badges"]))

            for guild in u["waifu"]:
                w = u["waifu"][guild]
                await self.query_executer("UPDATE necrobot.Waifu SET value = $1, flowers = $2 WHERE user_id = $3 AND guild_id = $4;", 
                                w["waifu-value"], w["flowers"], user, guild)

        with open("rings/utils/data/settings.json", "w") as outfile:
            json.dump(self.settings, outfile)
                
    async def broadcast(self):
        await self.wait_until_ready()
        channel = self.get_channel(318465643420712962)
        await channel.send("Initiating Broadcast")
        counter = 0
        try:
            while not self.is_closed():
                if counter >= 24:
                    counter = 0

                await asyncio.sleep(3600) # task runs every hour
                counter += 1

                for guild in self.server_data:
                    hour_mod = counter % self.server_data[guild]["broadcast-time"]
                    if self.server_data[guild]["broadcast"] != "" and self.server_data[guild]["broadcast-channel"] != "" and hour_mod == 0:
                        channel = self.get_channel(self.server_data[guild]["broadcast-channel"])
                        await channel.send(self.server_data[guild]["broadcast"])
        except Exception as e:
            self.dispatch("error")


    async def load_cache(self):
        self.pool = await asyncpg.create_pool(database="postgres", user="postgres", password=dbpass)
        channel = self.get_channel(318465643420712962)
        msg = await channel.send("**Initiating Bot**")
        for guild in self.guilds:
            if guild.id not in self.server_data:
                    self.server_data[guild.id] = self._new_server()
                    await self.query_executer("INSERT INTO necrobot.Guilds VALUES($1, 0, 0, 0, 'Welcome {member} to {server}!', 'Leaving so soon? We''ll miss you, {member}!)', '', 0, '', 1, 0, 5, 0);", guild.id)
        await msg.edit(content="All servers checked")

        members = self.get_all_members()
        for member in members:
            await self.default_stats(member, member.guild)
            
        await msg.edit(content="All members checked")
        await msg.edit(content="**Bot Online**")

        await self.change_presence(activity=discord.Game(name="n!help for help"))

    async def query_executer(self, query, *args):
        conn = await self.pool.acquire()
        result = []
        try:
            if query.startswith("SELECT"):
                result = await conn.fetch(query, *args)
            else:
                await conn.execute(query, *args)
        except Exception as error:
            print(error.as_dict())
            if isinstance(error, asyncpg.exceptions.ForeignKeyViolationError):
                if "fkey" in error.constraint_name and error.column_name == "user_id":
                    try:
                        await conn.execute("INSERT INTO necrobot.Users VALUES ($1, 200, 0, '          ', '', '', 'False');", member.id)
                        await conn.execute(query, *args)
                    except Exception as error:
                        pass

            channel = self.get_channel(415169176693506048)
            the_traceback = "```py\n" + " ".join(traceback.format_exception(type(error), error, error.__traceback__, chain=False)) + "\n```"
            embed = discord.Embed(title="DB Error", description=the_traceback, colour=discord.Colour(0x277b0))
            embed.add_field(name='Event', value=error)
            embed.add_field(name="Query", value=query)
            embed.add_field(name="Arguments", value=args)
            embed.set_footer(text="Generated by NecroBot", icon_url="https://cdn.discordapp.com/avatars/317619283377258497/a491c1fb5395e699148fcfed2ee755cf.jpg?size=128")
            await channel.send(embed=embed)
            
        finally:
            await self.pool.release(conn)
            return result

    # *****************************************************************************************************************
    #  Internal Checks
    # *****************************************************************************************************************
    async def default_stats(self, member, guild):
        if member.id not in self.user_data:
            self.user_data[int(member.id)] = {'money': 200, 'daily': '', 'title': '', 'exp': 0, 'perms': {}, 'badges':[], "waifu":{}, "warnings": {}, 'places':{"1":"", "2":"", "3":"", "4":"", "5":"", "6":"", "7":"", "8":""}, "tutorial": False}
            await self.query_executer("INSERT INTO necrobot.Users VALUES ($1, 200, 0, '          ', '', '', 'False');", member.id)
            await self.query_executer("""INSERT INTO necrobot.Badges VALUES ($1, 1, ''), ($1, 2, ''), ($1, 3, ''),
                                                                            ($1, 4, ''), ($1, 5, ''), ($1, 6, ''),
                                                                            ($1, 7, ''), ($1, 8, '');""", member.id)

        if isinstance(member, discord.User):
            member = guild.get_member(member.id)

        if guild.id not in self.user_data[member.id]["perms"]:
            if any(self.user_data[member.id]["perms"][x] == 7 for x in self.user_data[member.id]["perms"]):
                self.user_data[member.id]["perms"][guild.id] = 7
            elif any(self.user_data[member.id]["perms"][x] == 6 for x in self.user_data[member.id]["perms"]):
                self.user_data[member.id]["perms"][guild.id] = 6
            elif member.id == guild.owner.id:
                self.user_data[member.id]["perms"][guild.id] = 5
            elif member.guild_permissions.administrator:
                self.user_data[member.id]["perms"][guild.id] = 4
            else:
                self.user_data[member.id]["perms"][guild.id] = 0

            await self.query_executer("INSERT INTO necrobot.Permissions VALUES ($1,$2,$3);", guild.id, member.id, self.user_data[member.id]["perms"][guild.id])

        if guild.id not in self.user_data[member.id]["waifu"]:
            self.user_data[member.id]["waifu"][guild.id] = {"waifu-value":50, "waifu-claimer":"", "affinity":"", "heart-changes":0, "divorces":0, "waifus":[], "flowers":0, "gifts":{}}
            await self.query_executer("INSERT INTO necrobot.Waifu VALUES ($1,$2,50,0,0,0,0,0);", member.id, guild.id)

    # *****************************************************************************************************************
    # Events
    # *****************************************************************************************************************
    async def on_ready(self):
        await self.load_cache()
        print(self.server_data)
        print('------')
        print(f"Logged in as {self.user}")

    async def on_error(self, event, *args, **kwargs): 
        channel = self.get_channel(415169176693506048)
        error_t, error, _ = sys.exc_info()

        if error_t == KeyError:
            if isinstance(error.args[0], int):
                user = self.get_user(error.args[0])
                guild = self.get_guild(error.args[0])
                if guild:
                    if not error.args[0] in self.server_data:
                        #missing key in the server data
                        self.server_data[error.args[0]] = self._new_server()
                        await self.query_executer("INSERT INTO necrobot.Guilds VALUES($1, 0, 0, 0, 'Welcome {member} to {server}!', 'Leaving so soon? We''ll miss you, {member}!)', '', 0, '', 1, 0, 5, 0);", event.args[0])
                        await channel.send(f"Key Error detected and handled for data of guild **{guild}**, {guild.id}")
                    else:
                        #missing permission key in user data
                        for member in guild.members:
                            await self.default_stats(member, guild)
                        await channel.send(f"Key Error detected and handled for permissions of guild **{guild}**, {guild.id}")
                elif user:
                    #missing key in user data
                    guilds = [x for x in self.guilds if user in x.members]
                    for guild in guilds:
                        await self.default_stats(user, guild)
                    await channel.send(f"Key Error detected and handled for user {user.mention}")
            return

        the_traceback = f"```py\n{traceback.format_exc()}\n```"
        embed = discord.Embed(title="Error", description=the_traceback, colour=discord.Colour(0x277b0))
        embed.add_field(name='Event', value=event)
        embed.set_footer(text="Generated by NecroBot", icon_url="https://cdn.discordapp.com/avatars/317619283377258497/a491c1fb5395e699148fcfed2ee755cf.jpg?size=128")
        try:
            await channel.send(embed=embed)
        except discord.HTTPException:
            await channel.send(f'Bot: Ignoring exception in {event}')


    async def on_message(self, message):
        user_id = message.author.id
        channel_id = message.channel.id
        regex_match = r"(https://modding-union\.com/index\.php/topic).\d*"

        if message.author.bot or message.author.id in self.settings["blacklist"]:
            return

        if message.author.id not in self.user_data and message.guild:
            await self.default_stats(message.author, message.guild)

        url = re.search(regex_match, message.content)
        if not url is None:
            await self._mu_auto_embed(url.group(0), message)

        if message.attachments:
            if ".bmp" in message.attachments[0].filename:
                await self._bmp_converter(message)

        if not isinstance(message.channel, discord.DMChannel):
            self.user_data[user_id]["exp"] += random.randint(2,5)

            if not self._is_allowed_summon(message) and self._startswith_prefix(message):
                await message.delete()
                await message.channel.send(":negative_squared_cross_mark: | Commands not allowed in the channel or you are being ignored.", delete_after=5)
                return

            if message.content.startswith(self.user.mention):
                await message.channel.send(random.choice(replyList))
        else:
            if not self.user_data[message.author.id]["tutorial"]:
                self.user_data[message.author.id]["tutorial"] = True
                await message.channel.send(":information_source: | Did you know you can delete my messages in DMs by reacting to them with :wastebasket:? Give it a shot, react to this message with :wastebasket: .")
                await self.query_executer("UPDATE necrobot.Users SET tutorial = 'True' WHERE user_id = $1", message.author.id)

        await self.process_commands(message)


bot = NecroBot()

for extension in extensions:
    try:
        bot.load_extension("rings."+extension)
    except Exception as e:
        print(f'Failed to load extension {extension}.', file=sys.stderr)
        traceback.print_exc()

bot.run(token)
